---
title: Ants species coexistence
output:
    rmdformats::readthedown:
      collapsed: false
      highlight: kate
---

```{r setup}
library(EcoSimR)
library(dplyr)
detach("package:dplyr")
library("dplyr")
library(tidyr)
library(ggplot2)
library(performance)
library(glmmTMB)
library(ade4)
library(nlme)
library(ape)
library(vegan)
library(ggvegan)
#library(TPD)
```


```{r}

#see Cleaning.R in scripts folder for data cleaning
wide <- read.csv("Clean Data/ants_wide.csv")
cov <- read.csv("Clean Data/ants.csv")
sites <- read.csv("Clean Data/sites_joined.csv")
cov <- right_join(sites, cov, by = c("Site", "month"))

cov <- dplyr::select(cov, 3:10, 14:19, 22:36, 39:41)

#total count of ants
sum(cov$abun)

#add ecostress sensor data
eco <- read.csv("Clean Data/ecostress.csv")
eco <- select(eco, 1, 2, 11)
eco <- rename(eco, month = Category, Site = ID, esi = ECO4ESIPTJPL_001_Evaporative_Stress_Index_PT_JPL_ESIavg)
cov <- right_join(eco, cov, by = c("Site", "month"))

#read in foundation plant identity for the sites
shrubs <- read.csv("Clean Data/shrubs.csv")
cov <- right_join(cov, shrubs, by = "Site")
cov$shrub.site <- as.factor(cov$shrub.site)


#read in ndvi and soil data
ndvi <- read.csv("raw data/sites_remotesensing.csv")
ndvi <- select(ndvi, 7:17) %>%
  rename(Site = site)
ndvi$Site <- gsub("MoV", "Mov", ndvi$Site)
cov <- right_join(cov, ndvi, by = c("Site", "month"))
```




```{r}

#cleaning the raw trait data
traits <- read.csv("raw data/Traits.csv")

#check for spelling mistakes in trait labels
unique(traits$Trait)
#I don't trust the eye width measurements because they were measured from the front
traits <- filter(traits, Trait != "Eye width")
unique(traits$Photo)

#extract site IDs from photo names
traits <- separate(traits, Photo, c("Site", "Slide", "Specimen"))
traits$Site <- gsub("Papl", "PaPl", traits$Site)
unique(traits$Site)
traits <- traits[-1,]

#remove the double pheidole entry
traits <- traits[-2,]

#need to divide the trait values by weber's body length. I want to do this at the individual level, not dividing means by mean webers
traits <- select(traits, -X, -Label)
traits <- pivot_wider(traits, names_from = Trait, values_from = Measure)
traits <- mutate(traits, Femur.w = Femur/Webers, Scape.w = Scape/Webers, Mandible.w = `Mandible length`/Webers, Headl.w = `Head length`/Webers, Eyel.w = `Eye length`/Webers, Headw.w = `Head width`/Webers)
traits <- pivot_longer(traits, 5:17, names_to = "Trait", values_to = "Measure")

#check for ant species name typoes
unique(traits$X.1)

#some traits are NA because of damage to the specimen
traits <- drop_na(traits)

#calculate the mean value of the trait for each species at each site (population level trait values)
traits.ag <- group_by(traits, Site, X.1, Trait) %>%
  summarise(mean = mean(Measure), sd = sd(Measure))

#create a data frame of the mean values for each species across all sites (species level trait values)
traits.sp <- group_by(traits, X.1, Trait) %>% 
  summarise(mean = mean(Measure), sd = sd(Measure))

```

## CWM - Presence/absence

```{r}
#we could also try to log transform the abundances to reduce the impact of colony size 
#this is presence absence

long.pres <- pivot_longer(wide, 2:14, names_to = "species", values_to = "count")

long.pres <- mutate(long.pres, count.bin = ifelse(count >= 1, 1, 0))

spe.bin <- long.pres
#get total abundance per trap
long.pres <- group_by(long.pres, uniID) %>% 
  mutate(total = sum(count.bin)) 

#calculate relative abundances
long.pres <- long.pres %>% mutate(rel.abun = count.bin/total)

traits.ag <- rename(traits.ag, species = X.1)
traits.ag$species <- gsub(" ", "", traits.ag$species)

#add sites to long
long.pres <- cov %>% select(Site, uniID) %>% right_join(long.pres, . , by = 'uniID')
#this adds NA traits to 0 abundances - species isn't found at pitfall or site

  
join.right <- right_join(traits.ag, long.pres, by = c("Site", "species"))

CWM.pres <- mutate(join.right, cwm.prod = mean*rel.abun)

CWM.pres <- group_by(CWM.pres, Site, uniID, Trait) %>% summarise(cwm = sum(cwm.prod))

#join environmental data to CWM trait dataframe

CWM.pres <- left_join(CWM.pres, cov, by = "uniID")

```

```{r}
#make a presence/absence pitfall trap data frame

spe.bin <- select(spe.bin, 2, 3, 5)
spe.bin <- pivot_wider(spe.bin, names_from = species, values_from = count.bin)
spe.bin <- select(spe.bin, -11, -12)
```

# EDA

## Heat Map

```{r}

mat <- pivot_wider(CWM.pres, names_from = Trait, values_from = cwm)
mat <- select(mat, 5:11, 14:17, 25:29, 31, 38:44, 46, 48, 51, 52, 54, 55, 57) %>% ungroup()
mat <- ungroup(mat) %>% select(-uniID)
mat <- drop_na(mat)
#str(mat)
M <- cor(mat)
corrplot::corrplot(M, method = "number")

#just esi and env
mat2 <- select(mat, 1:11, 18:24)
M2 <- cor(mat2)
corrplot::corrplot(M2, method = "number")
```



## PCA for traits

### Invidividuals

```{r}
# I want the PCA on traits
# make it wide again

traits.wide <- pivot_wider(traits, names_from = Trait, values_from = Measure)
#keep only weber lengthh standardized traits
traits.wide <- select(traits.wide, 11:17)
traits.wide <- drop_na(traits.wide)

traits.st <- decostand(traits.wide, method = "standardize")
traits.pca <- rda(traits.st)

#summary(traits.pca)
autoplot(traits.pca, xlab = "PCA 33.9%", ylab = "PCA 32.9%")
#PC3 is ~15%

```


### Populations

```{r}

trait.pop <- traits.ag
trait.pop$spepop <- paste(trait.pop$species, trait.pop$Site)
trait.pop <- ungroup(trait.pop) %>% select(spepop, Trait, mean)
trait.pop <- pivot_wider(trait.pop, names_from = Trait, values_from = mean)
trait.pop <- select(trait.pop, 1, 3, 5, 8, 9, 11, 13, 14)

trait.pop.st <- select(trait.pop, -1) %>% decostand(method = "standardize")
trait.pop.pca <- rda(trait.pop.st)
#summary(trait.pop.pca)
autoplot(trait.pop.pca, xlab = "PCA 35.8%", ylab = "PCA 32.2 %")
#PCA3 ~ 16%
```

## Sites - pitfall traps

```{r}

env <- select(cov, 3:9, 12:15, 23:27, 29, 37:43) %>% drop_na()
#env.labels <- select(cov, 1:2)
#options(scipen = 999)
#env.pca <- rda(env, scaling = TRUE)
#summary(env.pca)
#autoplot(env.pca)
#doesn't look good

#standardize to mean of zero etc
#not sure if correct
env.d <- decostand(env, method = "standardize")
env.pca <- rda(env.d)
    
summary(env.pca)
autoplot(env.pca, xlab = "PCA 37.65%", ylab = "PCA 16.2%")
score2 <- scores(env.pca, c(1,2, 3), 'sites')
```


### Sites - site-level


```{r}

env2 <- select(cov, 3:5, 8, 12:15, 37:43) %>% drop_na() %>% distinct()


#standardize to mean of zero etc

env.d2 <- decostand(env2, method = "standardize")
env.pca2 <- rda(env.d2)
    
summary(env.pca2)
autoplot(env.pca2, xlab = "PCA 49.48%", ylab = "PCA 17.8%")

sitescores <- scores(env.pca2, c(1,2, 3), 'sites')

ggplot(env2, aes(site, esi)) + geom_boxplot()

env2noesi <- select(env2, -esi)

env.d2noesi <- decostand(env2noesi, method = "standardize")
env.pcanoesi <- rda(env.d2noesi)
    
summary(env.pcanoesi)
autoplot(env.pcanoesi, xlab = "PCA 50.66%", ylab = "PCA 18.8%")

sitescores2 <- scores(env.pcanoesi, c(1,2, 3), 'sites')

speciesscore <- scores(env.pca2, c(1,2, 3), 'species')

```

# Alpha diversity

### more data wrangling
```{r}


library(FD)

#need a species by trait matrix, but I want to use the population means
#make species name the name + site


site.pop <- select(cov, 1, 2, 31) %>% left_join(long.pres, ., by = 'uniID')

#count uniID per site and month
counts <- site.pop %>% group_by(Site.x, month, uniID) %>% count()
counts <- counts %>% group_by(Site.x, month) %>% count()

site.pop <- site.pop %>% group_by(Site.x, month, species) %>% summarize(total = sum(count.bin)) 

site.pop <- left_join(site.pop, counts, by = c("Site.x", "month"))


site.pop <- mutate(site.pop, pit.abun = total/n)
site.pop <- select(site.pop, 1:3, 6)
site.pop$site.name <- paste(site.pop$Site.x, site.pop$month)
site.pop$spepop <- paste(site.pop$species, site.pop$Site.x)
site.pop <- site.pop %>% ungroup() %>% select(4:6)


wide.pop <- pivot_wider(site.pop, names_from = spepop, values_from = pit.abun)
wide.pop[is.na(wide.pop)] <- 0
sites <- wide.pop$site.name

#there are no trait measurements for species that are absent from a site
wide.pop <- ungroup(wide.pop) %>% select(-site.name)
wide.pop <- wide.pop[which(colSums(wide.pop) !=0)]
wide.pop <- cbind(sites, wide.pop)
row.names(wide.pop) <- wide.pop$sites
wide.pop <- select(wide.pop, -sites)

#remove the two solenopsis singletons - no trait measuremnts

wide.pop <- select(wide.pop, -36, -42)


#check to ensure names are matched correctly between dataframes
spec <- colnames(wide.pop)

trait.pop <- as.data.frame(trait.pop)
row.names(trait.pop) <- trait.pop$spepop
trait.pop <- select(trait.pop, -spepop)

all.equal(spec, row.names(trait.pop))

```
### Null model/SES calculation

### Functional dispersion
```{r}
library(picante)


numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom <- matrix(NA, nrow = nrow(wide.pop), ncol = numberReps,
                        dimnames = list(rownames(wide.pop),
                                        paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
  randomizedFDis <- randomizeMatrix(samp = wide.pop, null.model = "independentswap")
  simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
  resultsRandom[, rep] <- simFDis
}

obsFDis <- dbFD(trait.pop, wide.pop, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis <- data.frame(SES3)
SES_dis$sites <- row.names(SES_dis)

#join site-level environmental measurements to data

cov$sites <- paste(cov$Site, cov$month)
SES <- select(cov, 1:15, shrub.site, sites, 37:43) %>% distinct() %>% left_join(SES_dis, by = "sites")

```

## Functional dispersion  EDA
```{r}

ggplot(SES, aes(esi, SES3, color = month)) + geom_smooth(method = 'lm')
ggplot(SES, aes(NDVI, SES3)) + geom_smooth(method = 'lm')

ggplot(SES, aes(Site, esi)) + geom_boxplot()
ggplot(SES, aes(arid, esi)) + geom_smooth(method = 'lm')

ggplot(SES, aes(arid, SES3)) + geom_smooth(method = 'lm')
ggplot(SES, aes(mean.cover, SES3)) + geom_smooth(method = 'lm')
ggplot(SES, aes(Max, SES3)) + geom_smooth()
ggplot(SES, aes(var.cover, SES3)) + geom_smooth()


mean(SES$SES3)
t.test(SES$SES3)

cor.test(SES$SES3, SES$esi)
cor.test(SES$SES3, SES$SBIO1_05)
cor.test(SES$SES3, SES$arid)


cor.test(SES$arid, SES$esi)
cor.test(SES$NDVI, SES$esi)
cor.test(SES$NDVI, SES$arid)
cor.test(SES$NDVI, SES$SES3)
cor.test(SES$arid, SES$Temp)
cor.test(SES$SES3, SES$Temp)
cor.test(SES$SES3, SES$Max)

cor.test(SES$SES3, SES$mean.cover)
cor.test(SES$esi, SES$mean.cover)
cor.test(SES$SES3, SES$mean.height)
cor.test(SES$SES3, SES$var.cover)
cor.test(SES$SES3, SES$var.height)

SES2 <- cbind(SES, sitescores)

m1 <- lm(SES3 ~ PC1, data = SES2)
summary(m1)



ggplot(SES2, aes(PC1, SES3)) + geom_smooth(method = "lm")



m1 <- glmmTMB(SES3 ~ arid +(1|Site) + (1|month), family = gaussian(), data = SES)
summary(m1)

m2 <- glmmTMB(SES3 ~  NDVI + SBIO1_05 + (1|Site), family = gaussian(), data = SES)
summary(m2)


m3 <- glmmTMB(ES3 ~ mean.cover + shrub.site + (1|Site), family = gaussian(), data = SES)
AIC(m1, m2, m3)

summary(m3)
summary(m1)
shapiro.test(resid(m2))

SES4 <- select(SES2, 1:25)
SESno <-cbind(SES4, sitescores2)

ggplot(SESno, aes(PC1, SES3)) + geom_smooth(method = "lm")
m1 <- lm(SES3 ~ PC1 + PC2 + PC3, data = SESno)
summary(m1)

```

#this actually takes the species-level traits instead of population level

### Functional dispersion - pitfall trap level null model calculations

```{r}
#let's do a null model for pitfall trap level, can randomize between sites?

#need a presence/absence matrix at the pitfall trap level, and want population-level means for this analysis, go from long.pres

long.pres$spepop <- paste(long.pres$species, long.pres$Site)
wide.pit.pop <- long.pres %>% 
  select(uniID, spepop, count.bin) %>%
  pivot_wider(names_from = spepop, values_from = count.bin) %>%
  as.data.frame()


wide.pit.pop[is.na(wide.pit.pop)] <- 0

row.names(wide.pit.pop) <- wide.pit.pop$uniID
wide.pit.pop <- select(wide.pit.pop, -uniID)

#remove zero rows and columns

wide.pit.pop <- wide.pit.pop[,colSums(wide.pit.pop) > 0]
wide.pit.pop <- select(wide.pit.pop, -36, -42)
wide.pit.pop <- wide.pit.pop[rowSums(wide.pit.pop) > 0,]



#check species name match up
spec <- colnames(wide.pit.pop)
all.equal(spec, row.names(trait.pop))

numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom3 <- matrix(NA, nrow = nrow(wide.pit.pop), ncol = numberReps,
                        dimnames = list(rownames(wide.pit.pop),
                                        paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
  randomizedFDis <- randomizeMatrix(samp = wide.pit.pop, null.model = "independentswap")
  simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
  resultsRandom3[, rep] <- simFDis
}

obsFDis <- dbFD(trait.pop, wide.pit.pop, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom3)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom3, 1, sd)
SES3 <- ES3 / sdNull3

SES_dis_pit <- data.frame(SES3)
SES_dis_pit$uniID <- row.names(SES_dis_pit)
SES_dis_pit <- rename(SES_dis_pit, SES_disp_pit = SES3)

SES_dis_pit <- left_join(SES_dis_pit, cov, by = "uniID")
#join site-level environmental measurements to data


SES_dis_pit <- cbind(SES_dis_pit, score2)

```
## Functional dispersion pitfall EDA


```{r}
mean(SES_dis_pit$SES_disp_pit, na.rm = TRUE)
t.test(SES_dis_pit$SES_disp_pit)

ggplot(SES_dis_pit, aes(Microsite, SES_disp_pit)) + geom_boxplot()
ggplot(SES_dis_pit, aes(esi, SES_disp_pit, color = Microsite)) + geom_smooth(method = "lm")

ggplot(SES_dis_pit, aes(arid, SES_disp_pit, color = Microsite)) + geom_smooth(method = "lm")


ggplot(SES_dis_pit, aes(esi, SES_disp_pit, color = shrub.site)) + geom_smooth(method = "lm")

m1 <- glmmTMB(SES_disp_pit ~ Microsite + arid  + (1|Site), family = "gaussian", data = SES_dis_pit)

summary(m1)
shapiro.test(resid(m1))
plot(resid(m1))

```

## Co-occurrence null models

```{r}

#rows are species and the columns are sites

library(purrr)

#join site-month codes to spebin

c_data <- dplyr::select(cov, uniID, sites) %>% right_join(spe.bin, by = 'uniID')
row.names(c_data) <- c_data$uniID
c_data <- split(c_data, c_data$sites)

# I think we only want to include species found somewhere within the site, so need to drop columns
#The matrix-wide C-score is not calculated for missing species, so empty rows in the matrix do not affect the result. 
#but! the null model needs no empty rows or columns

c_data <- map(c_data, ~ .x %>%
      select(-sites, -uniID) %>%
        select(which(!colSums(.) %in% 0)) %>%
        t()) 


c_data$`Aven Aug`


c_null <- map(c_data, ~.x %>%
                cooc_null_model(., algo = "sim2", metric = "c_score", nReps = 999))


c_null <- data.frame(do.call(rbind, c_null))
c_obs <- c_null$Obs
c_obs <- as.data.frame(c_obs)
c_obs <- t(c_obs)

c_sims <- as.data.frame(c_sims)
multiple.func <- function(x) {
      c(mean = mean(x), sd = sd(x))
}
c_sim <- apply(c_sims, 1, multiple.func)
c_sim <- t(c_sim)
c_obs <- cbind(c_obs, c_sim)
c_obs <- as.data.frame(c_obs)
c_obs <- mutate(c_obs, SES_C = (V1 - mean) / sd)

mean(c_obs$SES_C, na.rm = TRUE)
t.test(c_obs$SES_C, na.rm = TRUE)

# I think we aren't getting enough random matrices to actually create a distribution :(
# some have sd of 0

c_obs$sites <- row.names(c_obs)
c_obs$sites <- gsub("\\.", " ", c_obs$sites)

SES <- right_join(c_obs, SES, by = "sites")



ggplot(SES, aes(SES3, SES_C)) + geom_smooth(method = "lm")
ggplot(SES, aes(arid, SES_C)) + geom_smooth(method = "lm")




```

## Alpha diversity - species richness

```{r}


#site level


sites <- cov %>% drop_na()

m2 <- glmmTMB(Species ~ esi + Microsite+ arid + dry.veg.percent  + NDVI + SBIO1_05 + (1|Site) + (1|month), family = "poisson", data = cov)

summary(m2)

```

## db-RDA


```{r}

#We need to set up our data

#make a wide community data frame

cwm_wide <- CWM.pres %>% pivot_wider(names_from = Trait, values_from = cwm)

#drop non-standardized traits
cwm_wide <- select(cwm_wide, -45, -47, -49, -50, -53, -55)

#remove rows with zero abundance
cwm_wide <- filter(cwm_wide, abun > 0)
cwm_wide <- select(cwm_wide, 1, 2, 5:11, 14:17, 19, 25, 31, 35, 38:51)
# drop rows with NA values
cwm_wide <- drop_na(cwm_wide)
cwm_wide <- filter(cwm_wide, Webers > 0)
cwm_traits <- cwm_wide %>% ungroup() %>% select(25:31) 
cwm_env <- cwm_wide %>% ungroup() %>% select(1, 3:24)


m2 <- capscale(cwm_traits~  Prec+   Microsite +  NDVI   + Temp  + var.cover + Condition(Site.x), data = cwm_env, dist = "bray", metaMDSdist = TRUE)

m3 <- ordistep(m2, direction = "both")
summary(m2)
anova.cca(m2, by = "margin", model = "reduced", strata = cwm_env$Site.x)

vif.cca(m2)


plot(m2)

#for traits species should be rows, traits cols
traits.spe <- select(traits.sp, -sd)
traits.spe <- pivot_wider(traits.spe, names_from = Trait, values_from = mean)

#only keep corrected traits (divided by body length)
#only keep one head trait (keeping width)

traits.spe <- select(traits.spe, 1, 3,5, 9, 11, 13, 14)
traits.spe <- rename(traits.spe, species = X.1)
row.names(traits.spe) <- traits.spe$species
traits.spe <- as.data.frame(traits.spe) %>% ungroup()
traits.spe <- select(traits.spe, -species)
#I want veg height but there are NAs ugh

env4 <- select(cov, uniID, 2, 3, 4, 5,12, 13,15,  17, 23, 29, 34)
env4$Microsite <- as.factor(env4$Microsite)

naveg <- env4[is.na(env4$veg..height),]

#make a vector of NA values
naveg <- naveg$uniID
`%!in%` <- Negate(`%in%`)

#remove those NA rows from the species table
spe <- spe[spe$uniID %!in% naveg, ]
env4 <- env4[env4$uniID %!in% naveg, ]

row.names(env4) <- env4$uniID
env4 <- env4[,-1]



```



## Beta-diversity taxonomic



```{r}
library(betapart)

spe.bin.core <- betapart.core(spe.bin)
spe.bin.multi <- beta.multi(spe.bin)
spe.bin.samp <- beta.sample(spe.bin.core, sites = 9, samples = 100)


dist <- beta.pair(spe.bin, index.family = "sorensen")

bd <- vegan::betadisper(dist[[3]], env4$shrub.site)

boxplot(bd)
anova(bd)
# difference in dispersion between the three
TukeyHSD(bd)
# contrasts not significant. ok.

library(FD)
library(vegan)
gow <- gowdis(env4)
euc <- dist(env4, "euclidean")
gow <- as.matrix(gow)
sor <- dist[[3]]
sor <- as.matrix(sor)

sor.mean <- rowMeans(sor, na.rm = TRUE)
sim <- as.matrix(dist[[1]])
sim.mean <- rowMeans(sim, na.rm = TRUE)
sne <- as.matrix(dist[[2]])
sne.mean <- rowMeans(sne, na.rm = TRUE)

envbeta <- cbind(env4, sor.mean, sim.mean, sne.mean)


mb <- glmmTMB(sim.mean ~  arid  + esi + mean.cover +dry.veg.percent+  Microsite  + shrub.site + (1|Site), data = envbeta)
shapiro.test(resid(msor))
plot(resid(mb))
summary(mb)
check_collinearity(mb)

ggplot(envbeta, aes(arid, sor.mean)) + geom_smooth() 


msor <- glmmTMB(sor.mean ~  arid  + esi + mean.cover +dry.veg.percent+  Microsite  + shrub.site + (1|Site), data = envbeta)
summary(msor)
msor2 <- glmmTMB(sor.mean ~  arid  + esi + mean.cover +dry.veg.percent+  Microsite  + shrub.site , data = envbeta)

summary(msor2)

AIC(msor, msor2)

plot(resid(mb) ~ envbeta$sim.mean)
mb2 <- glmmTMB(sne.mean ~  arid   +mean.cover +dry.veg.percent+  Microsite  + shrub.site +(1|Site), data = envbeta)

size <- filter(CWM.pres, Trait == "Webers")
m1 <- glmmTMB(cwm ~ esi + (1|Site.x), data = size)
summary(m1)

m2 <- glmmTMB(cwm ~ arid + (1|Site.x), data = size)
summary(m2)

ggplot(size, aes(arid, cwm)) + geom_smooth(method = lm)


summary(mb)
summary(mb2)


envlong <- pivot_longer(envbeta, 11:13, names_to = "beta", values_to = "mean")

envlong <- pivot_longer(envlong, c(1:6, 8, 9), names_to = "env", values_to = "value")

ggplot(envlong, aes(value,mean , color = beta)) +
  stat_smooth(method = "lm") + facet_wrap(~env, scales = "free")



euc.dry <-dist(env4$dry.veg.percent, "euclidean")
euc.Prec <- dist(env4$Prec, "euclidean")
euc.esi <- dist(env4$esi, "euclidean")
euc.vegheight <- dist(env4$veg..height, "euclidean")
euc.temp <- dist(env4$Temp, "euclidean")
euc.siteveg <- dist(env4$mean.bare, "euclidean")
euc.arid <- dist(env4$arid, "euclidean")

mantel(euc.dry, sor, method = "spearman", permutations = 999, na.rm = TRUE)


mantel(euc.Prec, sor, method = "spearman", permutations = 99, na.rm = TRUE)

mantel(euc.Prec, gow, method = "spearman", permutations = 99, na.rm = TRUE)

mantel(euc.vegheight, sor, method = "spearman", permutations = 99, na.rm = TRUE)

mantel(euc.temp, sor, method = "spearman", permutations = 99, na.rm = TRUE)

mantel(euc.siteveg, sor, method = "spearman", permutations = 99, na.rm = TRUE)

mantel(euc.arid, sor, method = "spearman", permutations = 99, na.rm = TRUE)
mantel(euc.esi, sor, method = "spearman", permutations = 99, na.rm = TRUE)

n <- mantel(euc.arid, sim, method = "spearman", permutations = 99, na.rm = TRUE)
mantel(euc.esi, sim, method = "spearman", permutations = 99, na.rm = TRUE)

plot(n)

# dry.veg. percent matters
# site level differences do

#yes, beta diversity (species composition) is correlated with the environment

## Beta-diversity functional

## db-RDA






m0  <- capscale(cwm.comm ~ 1+ Condition(Site), data = cwm.env, dist = "bray")



m1 <- capscale(cwm.comm ~ Prec + esi +mean.cover +dry.veg.percent+  + month+ Condition(Site), data = cwm.env, dist = "bray")


m1 <- capscale(cwm.comm ~ arid + esi  +mean.cover +dry.veg.percent+  Microsite  + Condition(Site), data = cwm.env, dist = "bray")

RsquareAdj(m1)$r.squared
m1
plot.cca(m1)


cor.test(cwm.env$esi, cwm.env$arid)
plot(cwm.env$esi, cwm.env$arid)

ggplot(cwm.env, aes(esi, arid)) + geom_smooth()

plot(m1, type = "n", scaling = "sites")
text(m1, dis = "cn", scaling = "sites")
text(m1, dis = "sp", scaling = "sites", col = "red")

autoplot(m1, scaling = 1)

summary(m1)
anova(m1)
anova.cca(m1, by = "terms", strata = cwm.env$Site)
anova.cca(m1, by = "margin", strata = cwm.env$Site)
anova.cca(m1, by = "axis", strata = cwm.env$Site)
ordiplot(m1)
arrows(m1, "species")
pl <- ordiplot(m1, type = "none")
points(pl, "sites", pch=21, col="red", bg="yellow")
text(pl, "species", col="blue", cex=0.9, arrows = TRUE)
arrows(p1, "sites")

```



env4$Site <- as.factor(env4$Site)
evn4C <- select(env4, 2, 3, 7, 8, 9, 11)
#evn4C <- select(env4, 2:11)
#evn4C <- select(evn4C, 1, 3)


#shrub and open are really close
#gotta add shrub type

library(mvabund)
fit <- traitglm(spe.bin, evn4C, traits.spe, family = "binomial", method = "manyglm")
fit$fourth #notice LASSO penalty has shrunk many interactions to zero

#summary(fit, blcok = env4)

anova(fit, block = env4$Site, resamp = "case", nBoot = 99)
#signficant trait*env but takes 36 minutes to run

library(lattice)
a        = max( abs(fit$fourth.corner) )
colort   = colorRampPalette(c("blue","white","red")) 
plot.4th = levelplot(t(as.matrix(fit$fourth.corner)), xlab="Environmental Variables",
 ylab="Species traits", col.regions=colort(100), at=seq(-a, a, length=100),
 scales = list( x= list(rot = 45)))
print(plot.4th)

library(jtools)
summ(fit)
#test again for presence/absence
#ant abundance may be more related to colony size which is a trait




four.comb.ants.adj <- fourthcorner(env4, spe.bin,
traits.spe, modeltype = 6, p.adjust.method.G = "none",
p.adjust.method.D = "fdr", nrepet = 999)

four.comb.ants.adj 
plot(four.comb.ants.adj, alpha = 0.05, stat = "D2")
#why are the p adj so different for a bivariate correlation? 
#not sure


fit <- traitglm(spe.bin, env4, traits.spe,family = "binomial")
#summary(fit)
fit$fourth #notice LASSO penalty has shrunk many interactions to zero

a        = max( abs(fit$fourth.corner) )
colort   = colorRampPalette(c("blue","white","red")) 
plot.4th = levelplot(t(as.matrix(fit$fourth.corner)), xlab="Environmental Variables",
 ylab="Species traits", col.regions=colort(100), at=seq(-a, a, length=100),
 scales = list( x= list(rot = 45)))
print(plot.4th)



```
# Turnover vs ITV

Community mean trait values can shift along gradients due to differences in the species composition at the sites, and also due to intraspecific variation

Compare shifts in CWM measured along a gradient using site-specific trait values to global trait values


# ITV

Intraspecific trait variation

## Body size
```{r}

itv <- data.frame()

#body size
webers <- traits %>% filter(Trait == "Webers")
partition <- aov(Measure~X.1, data = webers)
summary(partition)



#ITV is a low component of overall variability

logWebers <- log(webers$Measure)
modPart <- lme(logWebers ~ 1, random = ~ 1 | Site / X.1, data = webers, na.action = na.omit)
varcompWeber <- ape::varcomp(modPart, scale = 1)
varcompWeber

#body size differences between individuals of the same species within a site account for 9.2% variation
#differences among species within a site account for 90.7%
#differences among species between sites accounts for 0 %
```

## Femur length

```{r}
# relative leg length
femur <- traits %>% filter(Trait == "Femur.w")
partition <- aov(Measure~X.1, data = femur)
summary(partition)

#ITV is 1.208/3.298 = 36.6% of variation

logFemur <- log(femur$Measure)
modPart <- lme(logFemur ~ 1, random = ~ 1 | Site / X.1, data = femur, na.action = na.omit)
varcompFemur <- ape::varcomp(modPart, scale = 1)
varcompFemur

#relative femur length differences between individuals of the same species within a site account for 31% variation
#differences among species within a site account for 66.7%
#differences among species between sites accounts for 2.4 %
```

## Scape length

```{r}
#scape length

scape <- traits %>% filter(Trait == "Scape.w")
partition <- aov(Measure~X.1, data = scape)
summary(partition)

#ITV is 0.706/4.632 = 15.2 % of variation

logScape <- log(scape$Measure)
modPart <- lme(logScape ~ 1, random = ~ 1 | Site / X.1, data = scape, na.action = na.omit)
varcompScape <- ape::varcomp(modPart, scale = 1)
varcompScape

#relative scape length differences between individuals of the same species within a site account for 15% variation
#differences among species within a site account for 84.5%
#differences among species between sites accounts for 0%
```

## Mandible length

```{r}
#mandible length

mandible <- traits %>% filter(Trait == "Mandible.w")
partition <- aov(Measure~X.1, data = mandible)
summary(partition)

#ITV is 0.3478/0.76 = 45.7 % of variation

logMandible <- log(mandible$Measure)
modPart <- lme(logMandible ~ 1, random = ~ 1 | Site / X.1, data = mandible, na.action = na.omit)
varcompMandible <- ape::varcomp(modPart, scale = 1)
varcompMandible

#relative mandible length differences between individuals of the same species within a site account for 36.6% variation
#differences among species within a site account for 63%
#differences among species between sites accounts for 0%
```

## Eye length

```{r}

#eye length

el <- traits %>% filter(Trait == "Eyel.w")
partition <- aov(Measure~X.1, data = el)
summary(partition)

#ITV is 0.06/0.31 = 21 % of variation

logEL <- log(el$Measure)
modPart <- lme(logEL ~ 1, random = ~ 1 | Site / X.1, data = el, na.action = na.omit)
varcompEL <- ape::varcomp(modPart, scale = 1)
varcompEL

#relative eye length differences between individuals of the same species within a site account for 24% variation
#differences among species within a site account for 75.9%
#differences among species between sites accounts for 0%
```

## Head width


```{r}
#head width

hw <- traits %>% filter(Trait == "Headw.w")
partition <- aov(Measure~X.1, data = hw)
summary(partition)

#ITV is 26%
0.49/(0.49+1.39)

logHW <- log(hw$Measure)
modPart <- lme(logHW ~ 1, random = ~ 1 | Site / X.1, data = hw, na.action = na.omit)
varcompHW <- ape::varcomp(modPart, scale = 1)
varcompHW

#relative head width differences between individuals of the same species within a site account for 21.8% variation
#differences among species within a site account for 78.1%
#differences among species between sites accounts for 0%


hl <- traits %>% filter(Trait == "Headl.w")
partition <- aov(Measure~X.1, data = hl)
summary(partition)
```

# Sorenson

However, in this study we used
the C-score to evaluate co-occurrence between each pair
of species as C-score = (a âˆ’ c) (b âˆ’ c), where a is the total
number of occurrences of one species, b is the total number
of occurrences of a second species, and c is the number of
sites that contain both species




Contrarily, the SÃ¸rensen index
(Dice 1945) measures the mean number of shared sites (i.e.,
grid cells in our study) between a species pair, calculated
as Sðœ™r = 2câˆ•(2c + a + b), where a, b and c are defined as
above. 




# Ant-habitat associations
## Indicator species analysis

- microsite
- shrub type at site
- study site

# Beta-diversity

```
# Co-occurence

Make dist dataframes for pairwise C-scores at site and pitfall trap level


pitlabels <- select(wide, 1 ,2)
pitwide <- wide
pitwide <- select(pitwide, -1, -2)
#make dataframe presence/absence
pitwide[pitwide > 1] <- 1
#calculate pairwise C-Scores
pitc <- designdist(t(pitwide), "(A-J)*(B-J)", "binary")
pitc <- as.matrix(pitc)

#let's try with a package
library(ecospat)
library(bipartite)

c <- C.score(pitwide, normalise = TRUE, FUN = hist)
C.score(pitwide, normalise = TRUE, FUN = print)
?C.score

library(eco)

```


# Models
## Ant abundance

```{r}
cov %>% group_by(month) %>% summarise(sum = sum(abun))


m1.m11 <- glmmTMB(abun ~ dry.veg.percent + Microsite + month + mean.cover + Prec + (1|Site), family = "poisson", data = cov)
summary(m1.m11)
check_overdispersion(m1.m11)

m1.mnb <- glmmTMB(abun ~ dry.veg.percent + Microsite + month + mean.cover + arid + esi + shrub.site + (1|Site), family = "nbinom2", data = cov)
summary(m1.mnb)


v1 <- glmmTMB(dry.veg.percent ~ Microsite + month +  arid * shrub.site + (1|Site), family = "nbinom2", data = cov)
summary(v1)


ggplot(cov, aes(arid, dry.veg.percent)) + geom_smooth()

```

## Ant richness

```{r}
m1 <- glmmTMB(Species ~ arid +mean.cover +dry.veg.percent + Microsite  + shrub.site + month + (1|Site) , family = "poisson", data = cov)
m2 <- glmmTMB(Species ~ arid dry.veg.percent + var.cover +Microsite  + shrub.site + month + (1|Site) , family = "poisson", data = cov)
m3 <- glmmTMB(Species ~ arid +mean.cover +dry.veg.percent + var.cover +Microsite  + shrub.site + month + esi + (1|Site) , family = "poisson", data = cov)
m4 <- glmmTMB(Species ~ arid +mean.cover +dry.veg.percent  +Microsite  + shrub.site + month + esi + (1|Site) , family = "poisson", data = cov)



m5 <- glmmTMB(Species ~ mean.cover +dry.veg.percent  +Microsite  + shrub.site +  esi + arid + (1|Site) , family = "poisson", data = cov)
summary(m5)
AIC(m1,m2, m3, m4, m5)

ggplot(cov, aes(arid, Species)) + geom_smooth()



cor.test(cov$mean.cover, cov$var.cover)

summary(m2)
library(performance)

check_collinearity(m5)
m2 <- glmmTMB(Species ~ dry.veg.percent + Microsite  + mean.cover +  esi + mean.height +  shrub.site + arid + month + (1|Site) , family = "nbinom2", data = cov)
summary(m2)

AIC(m1, m2)
```

## ITV Plots

```{r}

itv <- read.csv("raw data/itv.csv")
itv <- itv %>% mutate(total = Species + ITV) %>% mutate(sp.rel = Species/total, itv.rel = ITV/total)

itv = pivot_longer(itv, 5:6, names_to = "rel.itv", values_to = "val")

itv$Trait <- factor(itv$Trait, levels = unique(itv$Trait[order(itv$val)]))

ggplot(itv, aes(Trait, val, fill = rel.itv)) +geom_bar(position="stack", stat = "identity", aes(fill = rel.itv)) + ylab("Proportion variation explained by species") +
  theme(legend.position="none") + scale_fill_manual(values = c("gray", "black")) + theme(axis.text=element_text(size=12),
        axis.title=element_text(size=14,face="bold"))


```

ggplot(veg, aes(Microsite, dry.veg.percent)) + geom_violin() + geom_boxplot(width = 0.05) + theme(axis.text.x=element_text(angle=90, vjust=.5)) + ylab("Percent Cover Vegetation") + xlab("")  + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))
  
var <- dplyr::select(ants,1, 11:15, 17)
row.names(var) <- var$X
var <- dplyr::select(var, -X)
var$veg..height[is.na(var$veg..height)] <- 0


cov <- dplyr::select(ants, 1, 2, 3, 5)


pca1<- prcomp(var)
summary(pca1)
pca1

library(ggfortify)
autoplot(pca1, data = cov, colour = "Microsite", loadings = TRUE, loadings.label = TRUE)



## Functional richness

```{r}

numberReps <- 100

#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom4 <- matrix(NA, nrow = nrow(wide.pop), ncol = numberReps,
                        dimnames = list(rownames(wide.pop),
                                        paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
  randomizedFDis <- randomizeMatrix(samp = wide.pop, null.model = "independentswap")
  simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FRic
  resultsRandom4[, rep] <- simFDis
}

obsFDis <- dbFD(trait.pop, wide.pop, w.abun = TRUE)$FRic
meanNull3 <- rowMeans(resultsRandom4)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom4, 1, sd)
SES3 <- ES3 / sdNull3
SES_rich <- data.frame(SES3)
SES_rich$sites <- row.names(SES_rich)
#join site-level environmental measurements to data

SES_rich <- rename(SES_rich, SES_ric = SES3)
SES <- left_join(SES_rich, SES, by = "sites")




mean(SES$SES_ric, na.rm = TRUE)




```




## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
