#summary(traits.pca)
autoplot(traits.pca, xlab = "PCA 33.9%", ylab = "PCA 32.9%")
#PC3 is ~15%
trait.pop <- traits.ag
trait.pop$spepop <- paste(trait.pop$species, trait.pop$Site)
trait.pop <- ungroup(trait.pop) %>% select(spepop, Trait, mean)
trait.pop <- pivot_wider(trait.pop, names_from = Trait, values_from = mean)
trait.pop <- select(trait.pop, 1, 3, 5, 8, 9, 11, 13, 14)
trait.pop.st <- select(trait.pop, -1) %>% decostand(method = "standardize")
trait.pop.pca <- rda(trait.pop.st)
#summary(trait.pop.pca)
autoplot(trait.pop.pca, xlab = "PCA 35.8%", ylab = "PCA 32.2 %")
#PCA3 ~ 16%
env <- select(cov, 3:9, 12:15, 23:27, 29, 37:43) %>% drop_na()
#env.labels <- select(cov, 1:2)
#options(scipen = 999)
#env.pca <- rda(env, scaling = TRUE)
#summary(env.pca)
#autoplot(env.pca)
#doesn't look good
#standardize to mean of zero etc
#not sure if correct
env.d <- decostand(env, method = "standardize")
env.pca <- rda(env.d)
summary(env.pca)
autoplot(env.pca, xlab = "PCA 37.65%", ylab = "PCA 16.2%")
score2 <- scores(env.pca, c(1,2, 3), 'sites')
env2 <- select(cov, 3:9, 12:15, 37:43) %>% drop_na() %>% distinct()
#standardize to mean of zero etc
#not sure if correct
env.d2 <- decostand(env2, method = "standardize")
env.pca2 <- rda(env.d2)
summary(env.pca2)
autoplot(env.pca2, xlab = "PCA 49.48%", ylab = "PCA 17.8%")
sitescores <- scores(env.pca2, c(1,2, 3), 'sites')
library(FD)
#need a species by trait matrix, but I want to use the population means
#make species name the name + site
site.pop <- select(cov, 1, 2, 31) %>% left_join(long.pres, ., by = 'uniID')
#count uniID per site and month
counts <- site.pop %>% group_by(Site.x, month, uniID) %>% count()
counts <- counts %>% group_by(Site.x, month) %>% count()
site.pop <- site.pop %>% group_by(Site.x, month, species) %>% summarize(total = sum(count.bin))
site.pop <- left_join(site.pop, counts, by = c("Site.x", "month"))
site.pop <- mutate(site.pop, pit.abun = total/n)
site.pop <- select(site.pop, 1:3, 6)
site.pop$site.name <- paste(site.pop$Site.x, site.pop$month)
site.pop$spepop <- paste(site.pop$species, site.pop$Site.x)
site.pop <- site.pop %>% ungroup() %>% select(4:6)
wide.pop <- pivot_wider(site.pop, names_from = spepop, values_from = pit.abun)
wide.pop[is.na(wide.pop)] <- 0
sites <- wide.pop$site.name
#there are no trait measurements for species that are absent from a site
wide.pop <- ungroup(wide.pop) %>% select(-site.name)
wide.pop <- wide.pop[which(colSums(wide.pop) !=0)]
wide.pop <- cbind(sites, wide.pop)
row.names(wide.pop) <- wide.pop$sites
wide.pop <- select(wide.pop, -sites)
#remove the two solenopsis singletons - no trait measuremnts
wide.pop <- select(wide.pop, -36, -42)
#check to ensure names are matched correctly between dataframes
spec <- colnames(wide.pop)
trait.pop <- as.data.frame(trait.pop)
row.names(trait.pop) <- trait.pop$spepop
trait.pop <- select(trait.pop, -spepop)
all.equal(spec, row.names(trait.pop))
library(picante)
numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom <- matrix(NA, nrow = nrow(wide.pop), ncol = numberReps,
dimnames = list(rownames(wide.pop),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = wide.pop, null.model = "independentswap")
simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom[, rep] <- simFDis
}
obsFDis <- dbFD(trait.pop, wide.pop, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis <- data.frame(SES3)
SES_dis$sites <- row.names(SES_dis)
#join site-level environmental measurements to data
cov$sites <- paste(cov$Site, cov$month)
SES <- select(cov, 1:15, shrub.site, sites, 37:43) %>% distinct() %>% left_join(SES_dis, by = "sites")
ggplot(SES, aes(esi, SES3, color = month)) + geom_smooth(method = 'lm')
ggplot(SES, aes(NDVI, SES3)) + geom_smooth(method = 'lm')
ggplot(SES, aes(Site, esi)) + geom_boxplot()
ggplot(SES, aes(arid, esi)) + geom_smooth(method = 'lm')
ggplot(SES, aes(arid, SES3)) + geom_smooth(method = 'lm')
ggplot(SES, aes(mean.cover, SES3)) + geom_smooth(method = 'lm')
ggplot(SES, aes(Max, SES3)) + geom_smooth()
ggplot(SES, aes(var.cover, SES3)) + geom_smooth()
mean(SES$SES3)
t.test(SES$SES3)
cor.test(SES$SES3, SES$esi)
cor.test(SES$SES3, SES$SBIO1_05)
cor.test(SES$SES3, SES$arid)
cor.test(SES$arid, SES$esi)
cor.test(SES$NDVI, SES$esi)
cor.test(SES$NDVI, SES$arid)
cor.test(SES$NDVI, SES$SES3)
cor.test(SES$arid, SES$Temp)
cor.test(SES$SES3, SES$Temp)
cor.test(SES$SES3, SES$Max)
cor.test(SES$SES3, SES$mean.cover)
cor.test(SES$esi, SES$mean.cover)
cor.test(SES$SES3, SES$mean.height)
cor.test(SES$SES3, SES$var.cover)
cor.test(SES$SES3, SES$var.height)
SES2 <- cbind(SES, sitescores)
m1 <- lm(SES3 ~ PC1 + PC3, data = SES2)
summary(m1)
ggplot(SES, aes(PC1, SES3)) + geom_smooth(method = "lm")
m1 <- glmmTMB(SES3 ~ arid +(1|Site) + (1|month), family = gaussian(), data = SES)
summary(m1)
m2 <- glmmTMB(SES3 ~  NDVI + SBIO1_05 + (1|Site), family = gaussian(), data = SES)
summary(m2)
m3 <- glmmTMB(ES3 ~ mean.cover + shrub.site + (1|Site), family = gaussian(), data = SES)
AIC(m1, m2, m3)
summary(m1)
shapiro.test(resid(m2))
#let's do a null model for pitfall trap level, can randomize between sites?
#need a presence/absence matrix at the pitfall trap level, and want population-level means for this analysis, go from long.pres
long.pres$spepop <- paste(long.pres$species, long.pres$Site)
wide.pit.pop <- long.pres %>%
select(uniID, spepop, count.bin) %>%
pivot_wider(names_from = spepop, values_from = count.bin) %>%
as.data.frame()
wide.pit.pop[is.na(wide.pit.pop)] <- 0
row.names(wide.pit.pop) <- wide.pit.pop$uniID
wide.pit.pop <- select(wide.pit.pop, -uniID)
#remove zero rows and columns
wide.pit.pop <- wide.pit.pop[rowSums(wide.pit.pop) > 0,]
wide.pit.pop <- wide.pit.pop[,colSums(wide.pit.pop) > 0]
wide.pit.pop <- select(wide.pit.pop, -36, -42)
#check species name match up
spec <- colnames(wide.pit.pop)
all.equal(spec, row.names(trait.pop))
numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom3 <- matrix(NA, nrow = nrow(wide.pit.pop), ncol = numberReps,
dimnames = list(rownames(wide.pit.pop),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = wide.pit.pop, null.model = "independentswap")
simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom3[, rep] <- simFDis
}
obsFDis <- dbFD(trait.pop, wide.pit.pop, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom3)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom3, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis_pit <- data.frame(SES3)
SES_dis_pit$uniID <- row.names(SES_dis_pit)
SES_dis_pit <- rename(SES_dis_pit, SES_disp_pit = SES3)
SES_dis_pit <- left_join(SES_dis_pit, cov, by = "uniID")
#join site-level environmental measurements to data
SES_dis_pit <- cbind(SES_dis_pit, score2)
#let's do a null model for pitfall trap level, can randomize between sites?
#need a presence/absence matrix at the pitfall trap level, and want population-level means for this analysis, go from long.pres
long.pres$spepop <- paste(long.pres$species, long.pres$Site)
wide.pit.pop <- long.pres %>%
select(uniID, spepop, count.bin) %>%
pivot_wider(names_from = spepop, values_from = count.bin) %>%
as.data.frame()
wide.pit.pop[is.na(wide.pit.pop)] <- 0
row.names(wide.pit.pop) <- wide.pit.pop$uniID
wide.pit.pop <- select(wide.pit.pop, -uniID)
#remove zero rows and columns
wide.pit.pop <- wide.pit.pop[,colSums(wide.pit.pop) > 0]
wide.pit.pop <- wide.pit.pop[rowSums(wide.pit.pop) > 0,]
wide.pit.pop <- select(wide.pit.pop, -36, -42)
#check species name match up
spec <- colnames(wide.pit.pop)
all.equal(spec, row.names(trait.pop))
numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom3 <- matrix(NA, nrow = nrow(wide.pit.pop), ncol = numberReps,
dimnames = list(rownames(wide.pit.pop),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = wide.pit.pop, null.model = "independentswap")
simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom3[, rep] <- simFDis
}
obsFDis <- dbFD(trait.pop, wide.pit.pop, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom3)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom3, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis_pit <- data.frame(SES3)
SES_dis_pit$uniID <- row.names(SES_dis_pit)
SES_dis_pit <- rename(SES_dis_pit, SES_disp_pit = SES3)
SES_dis_pit <- left_join(SES_dis_pit, cov, by = "uniID")
#join site-level environmental measurements to data
SES_dis_pit <- cbind(SES_dis_pit, score2)
#let's do a null model for pitfall trap level, can randomize between sites?
#need a presence/absence matrix at the pitfall trap level, and want population-level means for this analysis, go from long.pres
long.pres$spepop <- paste(long.pres$species, long.pres$Site)
wide.pit.pop <- long.pres %>%
select(uniID, spepop, count.bin) %>%
pivot_wider(names_from = spepop, values_from = count.bin) %>%
as.data.frame()
wide.pit.pop[is.na(wide.pit.pop)] <- 0
row.names(wide.pit.pop) <- wide.pit.pop$uniID
wide.pit.pop <- select(wide.pit.pop, -uniID)
#remove zero rows and columns
wide.pit.pop <- wide.pit.pop[,colSums(wide.pit.pop) > 0]
wide.pit.pop <- wide.pit.pop[rowSums(wide.pit.pop) > 0,]
wide.pit.pop <- wide.pit.pop[rowSums(wide.pit.pop) > 0,]
wide.pit.pop <- select(wide.pit.pop, -36, -42)
#check species name match up
spec <- colnames(wide.pit.pop)
all.equal(spec, row.names(trait.pop))
numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom3 <- matrix(NA, nrow = nrow(wide.pit.pop), ncol = numberReps,
dimnames = list(rownames(wide.pit.pop),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = wide.pit.pop, null.model = "independentswap")
simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom3[, rep] <- simFDis
}
obsFDis <- dbFD(trait.pop, wide.pit.pop, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom3)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom3, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis_pit <- data.frame(SES3)
SES_dis_pit$uniID <- row.names(SES_dis_pit)
SES_dis_pit <- rename(SES_dis_pit, SES_disp_pit = SES3)
SES_dis_pit <- left_join(SES_dis_pit, cov, by = "uniID")
#join site-level environmental measurements to data
SES_dis_pit <- cbind(SES_dis_pit, score2)
wide.pit.pop <- wide.pit.pop[rowSums(wide.pit.pop) > 0,]
long.pres$spepop <- paste(long.pres$species, long.pres$Site)
wide.pit.pop <- long.pres %>%
select(uniID, spepop, count.bin) %>%
pivot_wider(names_from = spepop, values_from = count.bin) %>%
as.data.frame()
wide.pit.pop[is.na(wide.pit.pop)] <- 0
row.names(wide.pit.pop) <- wide.pit.pop$uniID
wide.pit.pop <- select(wide.pit.pop, -uniID)
wide.pit.pop <- wide.pit.pop[,colSums(wide.pit.pop) > 0]
wide.pit.pop <- wide.pit.pop[rowSums(wide.pit.pop) > 0,]
View(wide.pit.pop)
#I don't understand why I need to manually run this>
wide.pit.pop <- wide.pit.pop[rowSums(wide.pit.pop) > 0,]
#I don't understand why I need to manually run this>
wide.pit.pop <- wide.pit.pop[rowSums(wide.pit.pop) > 0,]
wide.pit.pop <- select(wide.pit.pop, -36, -42)
#I don't understand why I need to manually run this>
wide.pit.pop <- wide.pit.pop[rowSums(wide.pit.pop) > 0,]
#let's do a null model for pitfall trap level, can randomize between sites?
#need a presence/absence matrix at the pitfall trap level, and want population-level means for this analysis, go from long.pres
long.pres$spepop <- paste(long.pres$species, long.pres$Site)
wide.pit.pop <- long.pres %>%
select(uniID, spepop, count.bin) %>%
pivot_wider(names_from = spepop, values_from = count.bin) %>%
as.data.frame()
wide.pit.pop[is.na(wide.pit.pop)] <- 0
row.names(wide.pit.pop) <- wide.pit.pop$uniID
wide.pit.pop <- select(wide.pit.pop, -uniID)
#remove zero rows and columns
wide.pit.pop <- wide.pit.pop[,colSums(wide.pit.pop) > 0]
wide.pit.pop <- select(wide.pit.pop, -36, -42)
wide.pit.pop <- wide.pit.pop[rowSums(wide.pit.pop) > 0,]
#check species name match up
spec <- colnames(wide.pit.pop)
all.equal(spec, row.names(trait.pop))
numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom3 <- matrix(NA, nrow = nrow(wide.pit.pop), ncol = numberReps,
dimnames = list(rownames(wide.pit.pop),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = wide.pit.pop, null.model = "independentswap")
simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom3[, rep] <- simFDis
}
obsFDis <- dbFD(trait.pop, wide.pit.pop, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom3)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom3, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis_pit <- data.frame(SES3)
SES_dis_pit$uniID <- row.names(SES_dis_pit)
SES_dis_pit <- rename(SES_dis_pit, SES_disp_pit = SES3)
SES_dis_pit <- left_join(SES_dis_pit, cov, by = "uniID")
#join site-level environmental measurements to data
SES_dis_pit <- cbind(SES_dis_pit, score2)
mean(SES_dis_pit$SES_disp_pit, na.rm = TRUE)
t.test(SES_dis_pit$SES_disp_pit)
ggplot(SES_dis_pit, aes(Microsite, SES_disp_pit)) + geom_boxplot()
ggplot(SES_dis_pit, aes(esi, SES_disp_pit, color = Microsite)) + geom_smooth(method = "lm")
ggplot(SES_dis_pit, aes(arid, SES_disp_pit, color = Microsite)) + geom_smooth(method = "lm")
ggplot(SES_dis_pit, aes(esi, SES_disp_pit, color = shrub.site)) + geom_smooth(method = "lm")
m1 <- glmmTMB(SES_disp_pit ~ Microsite + arid  + (1|Site), family = "gaussian", data = SES_dis_pit)
summary(m1)
shapiro.test(resid(m1))
plot(resid(m1))
c_data <- dplyr::select(cov, uniID, sites) %>% right_join(spe.bin, by = 'uniID')
c_data <- dplyr::select(c_data, -uniID)
c_data <- split(c_data, c_data$sites)
c_data <- select(c_data, -uniID)
c_data <- lapply(c_data, function(x) {
select(-uniID)
})
library(purrr)
map(c_data, ~ .x %>%
select(-uniID))
map(c_data, ~ .x %>%
select(-sites))
c_data <- map(c_data, ~ .x %>%
select(-sites))
c_data <- dplyr::select(cov, uniID, sites) %>% right_join(spe.bin, by = 'uniID')
c_data <- dplyr::select(c_data, -uniID)
c_data <- split(c_data, c_data$sites)
c_data <- map(c_data, ~ .x %>%
select(-sites) %>%
t())
c_data$`Aven Aug`
c_data <- dplyr::select(cov, uniID, sites) %>% right_join(spe.bin, by = 'uniID')
c_data <- split(c_data, c_data$sites)
c_data <- map(c_data, ~ .x %>%
select(-sites) %>%
t())
c_data$`Aven Aug`
c_data <- dplyr::select(cov, uniID, sites) %>% right_join(spe.bin, by = 'uniID')
row.names(c_data) <- c_data$uniID
View(c_data)
c_data <- split(c_data, c_data$sites)
c_data <- map(c_data, ~ .x %>%
select(-sites, -uniID) %>%
t())
c_data$`Aven Aug`
c_data <- dplyr::select(cov, uniID, sites) %>% right_join(spe.bin, by = 'uniID')
row.names(c_data) <- c_data$uniID
c_data <- split(c_data, c_data$sites)
# I think we only want to include species found somewhere within the site, so need to drop columns
c_data <- map(c_data, ~ .x %>%
select(-sites, -uniID) %>%
select(which(!colSums() %in% 0)) %>%
t())
# I think we only want to include species found somewhere within the site, so need to drop columns
c_data <- map(c_data, ~ .x %>%
select(-sites, -uniID) %>%
select(which(!colSums(.x) %in% 0)) %>%
t())
# I think we only want to include species found somewhere within the site, so need to drop columns
c_data <- map(c_data, ~ .x %>%
select(-sites, -uniID) %>%
select(which(!colSums(.) %in% 0)) %>%
t())
c_data$`Aven Aug`
c_data <- dplyr::select(cov, uniID, sites) %>% right_join(spe.bin, by = 'uniID')
row.names(c_data) <- c_data$uniID
c_data <- split(c_data, c_data$sites)
# I think we only want to include species found somewhere within the site, so need to drop columns
#The matrix-wide C-score is not calculated for missing species, so empty rows in the matrix do not affect the result.
#a
c_data <- map(c_data, ~ .x %>%
select(-sites, -uniID) %>%
t())
c_data$`Aven Aug`
c_data <- dplyr::select(cov, uniID, sites) %>% right_join(spe.bin, by = 'uniID')
row.names(c_data) <- c_data$uniID
c_data <- split(c_data, c_data$sites)
c_data <- map(c_data, ~ .x %>%
select(-sites, -uniID) %>%
select(which(!colSums(.) %in% 0)) %>%
filter(which(!rowSums(.) %in% 0)) %>%
t())
c_data <- map(c_data, ~ .x %>%
select(-sites, -uniID) %>%
select(which(!colSums(.) %in% 0)) %>%
filter(rowSums == 0) %>%
t())
c_data <- map(c_data, ~ .x %>%
select(-sites, -uniID) %>%
select(which(!colSums(.) %in% 0)) %>%
filter(rowSums > 0) %>%
t())
c_data <- map(c_data, ~ .x %>%
select(-sites, -uniID) %>%
select(which(!colSums(.) %in% 0)) %>%
filter(rowSums(.) > 0) %>%
t())
c_data$`Aven Aug`
c_null <- map(c_data, ~.x %>%
cooc_null_model(., algo = "sim9", metric = "c_score", nReps = 10))
c_null <- map(c_data, ~.x %>%
cooc_null_model(., algo = "sim9", metric = "c_score", nReps = 9))
c_null <- map(c_data, ~.x %>%
cooc_null_model(., algo = "sim9", metric = "c_score", nReps = 100))
c_obs <- map(c_null, obs)
c_obs <- map(c_null, .x$obs)
c_obs <- data.frame(do.call(rbind, c_null$obs))
c_obs <- data.frame(do.call(rbind, c_null))
c_sims <- c_obs$Sim
c_obs <- c_obs$Obs
c_sims <- data.frame(do.call(rbind, c_sims))
c_null <- data.frame(do.call(rbind, c_null))
c_obs <- c_null$Obs
c_obs <- as.data.frame(c_obs)
View(c_obs)
c_sims <- as.data.frame(c_sims)
View(c_sims)
multiple.func <- function(x) {
c(mean = mean(x), sd = sd(x))
}
c_sim <- apply(c_sims, 1, multiple.func)
View(c_sim)
c_sim <- t(c_sim)
View(c_sim)
c_obs <- cbind(c_obs, c_sim)
View(c_obs)
c_null <- data.frame(do.call(rbind, c_null))
c_obs <- c_null$Obs
c_obs <- as.data.frame(c_obs)
c_null <- map(c_data, ~.x %>%
cooc_null_model(., algo = "sim9", metric = "c_score", nReps = 100))
c_null <- data.frame(do.call(rbind, c_null))
c_obs <- c_null$Obs
c_obs <- as.data.frame(c_obs)
View(c_obs)
c_obs <- t(c_obs)
c_sims <- as.data.frame(c_sims)
c_sim <- apply(c_sims, 1, multiple.func)
c_sim <- t(c_sim)
c_obs <- cbind(c_obs, c_sim)
View(c_obs)
c_obs <- mutate(c_obs, SES_C = (V1 - mean) / sd)
c_obs <- as.data.frame(C-obs)
c_obs <- as.data.frame(c_obs)
c_obs <- mutate(c_obs, SES_C = (V1 - mean) / sd)
mean(c_obs$SES_C)
mean(c_obs$SES_C, na.rm = TRUE)
t.test(c_obs$SES_C, na.rm = TRUE)
dat <- c_null$Randomized.Data
sir <- dat$`SiCr Sept`
View(sir)
sir <- as.data.frame(sir)
View(sir)
c_data <- dplyr::select(cov, uniID, sites) %>% right_join(spe.bin, by = 'uniID')
row.names(c_data) <- c_data$uniID
c_data <- split(c_data, c_data$sites)
c_data <- map(c_data, ~ .x %>%
select(-sites, -uniID) %>%
select(which(!colSums(.) %in% 0)) %>%
t())
c_data$`Aven Aug`
c_null <- map(c_data, ~.x %>%
cooc_null_model(., algo = "sim2", metric = "c_score", nReps = 100))
c_null <- data.frame(do.call(rbind, c_null))
c_obs <- c_null$Obs
c_obs <- as.data.frame(c_obs)
c_obs <- t(c_obs)
c_sims <- as.data.frame(c_sims)
multiple.func <- function(x) {
c(mean = mean(x), sd = sd(x))
}
c_sim <- apply(c_sims, 1, multiple.func)
c_sim <- t(c_sim)
c_obs <- cbind(c_obs, c_sim)
c_obs <- as.data.frame(c_obs)
c_obs <- mutate(c_obs, SES_C = (V1 - mean) / sd)
mean(c_obs$SES_C, na.rm = TRUE)
t.test(c_obs$SES_C, na.rm = TRUE)
c_null <- map(c_data, ~.x %>%
cooc_null_model(., algo = "sim2", metric = "c_score", nReps = 999))
c_null <- data.frame(do.call(rbind, c_null))
c_obs <- c_null$Obs
c_obs <- as.data.frame(c_obs)
c_obs <- t(c_obs)
c_sims <- as.data.frame(c_sims)
multiple.func <- function(x) {
c(mean = mean(x), sd = sd(x))
}
c_sim <- apply(c_sims, 1, multiple.func)
c_sim <- t(c_sim)
c_obs <- cbind(c_obs, c_sim)
c_obs <- as.data.frame(c_obs)
c_obs <- mutate(c_obs, SES_C = (V1 - mean) / sd)
mean(c_obs$SES_C, na.rm = TRUE)
t.test(c_obs$SES_C, na.rm = TRUE)
View(SES)
c_obs$sites <- row.names(c_obs)
SES <- right_join(c_obs, SES, by = "sites")
View(c_obs)
select(SES, -1, -2, -3)
SES <- select(SES, -1, -2, -3)
SES <- right_join(c_obs, SES, by = "sites")
c_obs$sites <- gsub(".", " ", c_obs$sites)
c_obs$sites <- row.names(c_obs)
c_obs$sites <- gsub(".", " ", c_obs$sites)
c_obs$sites <- row.names(c_obs)
c_obs$sites <- gsub("'.'", " ", c_obs$sites)
c_obs$sites <- gsub("\\.", " ", c_obs$sites)
SES <- select(SES, -1, -2, -3)
SES <- select(SES, -1, -3)
SES <- right_join(c_obs, SES, by = "sites")
ggplot(SES, aes(SES3, SES_C, color = Microsite)) + geom_smooth(method = "lm")
ggplot(SES, aes(SES3, SES_C)) + geom_smooth(method = "lm")
cor.test(SES$SES_C, SES$SES3)
ggplot(SES, aes(esi, SES_C)) + geom_smooth(method = "lm")
ggplot(SES, aes(arid, SES_C)) + geom_smooth(method = "lm")
