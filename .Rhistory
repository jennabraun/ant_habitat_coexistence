traits$Site <- gsub("Papl", "PaPl", traits$Site)
unique(traits$Site)
traits <- traits[-1,]
#remove the double pheidole entry
traits <- traits[-2,]
#need to divide the trait values by weber's body length. I want to do this at the individual level
traits <- select(traits, -X, -Label)
traits <- pivot_wider(traits, names_from = Trait, values_from = Measure)
traits <- mutate(traits, Femur.w = Femur/Webers, Scape.w = Scape/Webers, Mandible.w = `Mandible length`/Webers, Headl.w = `Head length`/Webers, Eyel.w = `Eye length`/Webers, Headw.w = `Head width`/Webers)
traits <- pivot_longer(traits, 5:17, names_to = "Trait", values_to = "Measure")
unique(traits$X.1)
#some traits are NA because of damage to the specimen
traits <- drop_na(traits)
#calculate the mean value of the trait for each species at each site
traits.ag <- group_by(traits, Site, X.1, Trait) %>%
summarise(mean = mean(Measure), sd = sd(Measure))
#create a data frame of the mean values for each species across all sites
traits.sp <- group_by(traits, X.1, Trait) %>%
summarise(mean = mean(Measure), sd = sd(Measure))
#calculate CWM trait values
#I want to do abundance
#it's proportional abundances
site.j <- select(cov, uniID, Site)
wide <- right_join(site.j, wide, by = "uniID")
wide <- select(wide, -X)
#remove the two other solenopsis species with 1 individual
wide <- select(wide, -12, -13)
#wide <- rename(wide, Site = Site.x) %>%
#select(-Site.y)
long <- pivot_longer(wide, 3:13, names_to = "species", values_to = "count")
#get total abundance per trap
long <- group_by(long, uniID) %>%
mutate(total = sum(count))
long <- long %>% mutate(rel.abun = count/total)
traits.ag <- rename(traits.ag, species = X.1)
traits.ag$species <- gsub(" ", "", traits.ag$species)
#this adds NA traits to 0 abundances - species isn't found at pitfall or site
join.right <- right_join(traits.ag, long, by = c("Site", "species"))
#join.left <- left_join(traits.ag, long, by = c("Site", "species"))
CWM <- mutate(join.right, cwm.prod = mean*rel.abun)
CWM <- group_by(CWM, Site, uniID, Trait) %>% summarise(cwm = sum(cwm.prod))
#can log transform the abundances to look at dominants vs subordinates
#join environmental data to CWM trait dataframe
CWM <- left_join(CWM, cov, by = "uniID")
# Chunk 3
long.pres <- pivot_longer(wide, 3:13, names_to = "species", values_to = "count")
long.pres <- mutate(long.pres, count.bin = ifelse(count >= 1, 1, 0))
#get total abundance per trap
long.pres <- group_by(long.pres, uniID) %>%
mutate(total = sum(count.bin))
long.pres <- long.pres %>% mutate(rel.abun = count.bin/total)
#traits.ag <- rename(traits.ag, species = X.1)
#traits.ag$species <- gsub(" ", "", traits.ag$species)
#this adds NA traits to 0 abundances - species isn't found at pitfall or site
join.right <- right_join(traits.ag, long.pres, by = c("Site", "species"))
#join.left <- left_join(traits.ag, long, by = c("Site", "species"))
CWM.pres <- mutate(join.right, cwm.prod = mean*rel.abun)
CWM.pres <- group_by(CWM.pres, Site, uniID, Trait) %>% summarise(cwm = sum(cwm.prod))
#can log transform the abundances to look at dominants vs subordinates
#join environmental data to CWM trait dataframe
CWM.pres <- left_join(CWM.pres, cov, by = "uniID")
# Chunk 4
CWM <- rename(CWM, Site = Site.x)
# Chunk 5
mat <- pivot_wider(CWM, names_from = Trait, values_from = cwm)
mat <- select(mat, 5:11, 14:17, 25:31, 36:48) %>% ungroup()
mat <- ungroup(mat) %>% select(-uniID)
mat <- drop_na(mat)
#str(mat)
M <- cor(mat)
corrplot::corrplot(M, method = "number")
# Chunk 6
# I want the PCA on traits
# make it wide again
traits.wide <- pivot_wider(traits, names_from = Trait, values_from = Measure)
traits.wide <- select(traits.wide, 11:17)
traits.wide <- drop_na(traits.wide)
library(vegan)
library(ggvegan)
traits.pca <- rda(traits.wide)
#summary(traits.pca)
#no scaling because the traits all have the same units
autoplot(traits.pca, xlab = "PCA 82.8%", ylab = "PCA 10.5%")
# Chunk 7
library(vegan)
env <- select(cov, 3:9, 12:15, 23:27, 29) %>% drop_na()
env.labels <- select(cov, 1:2)
options(scipen = 999)
env.pca <- rda(env, scaling = TRUE)
#summary(env.pca)
autoplot(env.pca)
#doesn't look good
#standardize to mean of zero etc
#not sure if correct
env.d <- decostand(env, method = "standardize")
env.pca <- rda(env.d)
#summary(env.pca)
autoplot(env.pca, xlab = "PCA 31.4%", ylab = "PCA 20.3%")
# Chunk 8
itv <- data.frame()
#body size
webers <- traits %>% filter(Trait == "Webers")
partition <- aov(Measure~X.1, data = webers)
summary(partition)
#ITV is a low component of overall variability
logWebers <- log(webers$Measure)
modPart <- lme(logWebers ~ 1, random = ~ 1 | Site / X.1, data = webers, na.action = na.omit)
varcompWeber <- ape::varcomp(modPart, scale = 1)
varcompWeber
#body size differences between individuals of the same species within a site account for 9.2% variation
#differences among species within a site account for 90.7%
#differences among species between sites accounts for 0 %
# Chunk 9
# relative leg length
femur <- traits %>% filter(Trait == "Femur.w")
partition <- aov(Measure~X.1, data = femur)
summary(partition)
#ITV is 1.208/3.298 = 36.6% of variation
logFemur <- log(femur$Measure)
modPart <- lme(logFemur ~ 1, random = ~ 1 | Site / X.1, data = femur, na.action = na.omit)
varcompFemur <- ape::varcomp(modPart, scale = 1)
varcompFemur
#relative femur length differences between individuals of the same species within a site account for 31% variation
#differences among species within a site account for 66.7%
#differences among species between sites accounts for 2.4 %
# Chunk 10
#scape length
scape <- traits %>% filter(Trait == "Scape.w")
partition <- aov(Measure~X.1, data = scape)
summary(partition)
#ITV is 0.706/4.632 = 15.2 % of variation
logScape <- log(scape$Measure)
modPart <- lme(logScape ~ 1, random = ~ 1 | Site / X.1, data = scape, na.action = na.omit)
varcompScape <- ape::varcomp(modPart, scale = 1)
varcompScape
#relative scape length differences between individuals of the same species within a site account for 15% variation
#differences among species within a site account for 84.5%
#differences among species between sites accounts for 0%
# Chunk 11
#mandible length
mandible <- traits %>% filter(Trait == "Mandible.w")
partition <- aov(Measure~X.1, data = mandible)
summary(partition)
#ITV is 0.3478/0.76 = 45.7 % of variation
logMandible <- log(mandible$Measure)
modPart <- lme(logMandible ~ 1, random = ~ 1 | Site / X.1, data = mandible, na.action = na.omit)
varcompMandible <- ape::varcomp(modPart, scale = 1)
varcompMandible
#relative mandible length differences between individuals of the same species within a site account for 36.6% variation
#differences among species within a site account for 63%
#differences among species between sites accounts for 0%
# Chunk 12
#eye length
el <- traits %>% filter(Trait == "Eyel.w")
partition <- aov(Measure~X.1, data = el)
summary(partition)
#ITV is 0.06/0.31 = 21 % of variation
logEL <- log(el$Measure)
modPart <- lme(logEL ~ 1, random = ~ 1 | Site / X.1, data = el, na.action = na.omit)
varcompEL <- ape::varcomp(modPart, scale = 1)
varcompEL
#relative eye length differences between individuals of the same species within a site account for 24% variation
#differences among species within a site account for 75.9%
#differences among species between sites accounts for 0%
# Chunk 13
#head width
hw <- traits %>% filter(Trait == "Headw.w")
partition <- aov(Measure~X.1, data = hw)
summary(partition)
#ITV is 26%
0.49/(0.49+1.39)
logHW <- log(hw$Measure)
modPart <- lme(logHW ~ 1, random = ~ 1 | Site / X.1, data = hw, na.action = na.omit)
varcompHW <- ape::varcomp(modPart, scale = 1)
varcompHW
#relative head width differences between individuals of the same species within a site account for 21.8% variation
#differences among species within a site account for 78.1%
#differences among species between sites accounts for 0%
hl <- traits %>% filter(Trait == "Headl.w")
partition <- aov(Measure~X.1, data = hl)
summary(partition)
# Chunk 14
#We need to set up our data
spe <- wide
#for traits species should be rows, traits cols
traits.spe <- select(traits.sp, -sd)
traits.spe <- pivot_wider(traits.spe, names_from = Trait, values_from = mean)
#only keep corrected traits (divided by body length)
#only keep one head trait (keeping width)
traits.spe <- select(traits.spe, 1, 3,5, 9, 11, 13, 14)
traits.spe <- rename(traits.spe, species = X.1)
row.names(traits.spe) <- traits.spe$species
traits.spe <- as.data.frame(traits.spe) %>% ungroup()
traits.spe <- select(traits.spe, -species)
#I want veg height but there are NAs ugh
env4 <- select(cov, uniID, 2, 3, 4, 5,12, 13,15,  17, 23, 29, 34)
env4$Microsite <- as.factor(env4$Microsite)
naveg <- env4[is.na(env4$veg..height),]
#make a vector of NA values
naveg <- naveg$uniID
`%!in%` <- Negate(`%in%`)
#remove those NA rows from the species table
spe <- spe[spe$uniID %!in% naveg, ]
env4 <- env4[env4$uniID %!in% naveg, ]
row.names(env4) <- env4$uniID
env4 <- env4[,-1]
row.names(spe) <- spe$uniID
spe <- select(spe, -1, -2)
spe.bin <- spe
spe.bin[spe.bin > 1] <- 1
# Chunk 15
#get rid of zero rows in species data and also in environmental data
zero <- filter(spe.bin,rowSums(spe.bin)!=0)
zeroID <- row.names(zero)
zeroenv <- cov[cov$uniID %in% zeroID, ]
envz <- select(zeroenv,2,  3:9, 12, 15, 17, 23, 29, 34)
#wow so many zeros?
#nm <- metaMDS(zero)
#envfit(nm ~ esi +mean.cover + dry.veg.percent + shrub.site + Microsite + var.cover + veg..height + mean.height + Temp,envz, strata = envz$Site, perm = 999)
# m1 <- cca(zero ~ esi +mean.cover + dry.veg.percent + shrub.site + Microsite + var.cover + veg..height + mean.height + Temp + Site,envz, perm = 999)
# summary(m1)
# anova.cca(m1, by = "margin")
library(FD)
trait.pop <- traits.ag
trait.pop$spepop <- paste(trait.pop$species, trait.pop$Site)
trait.pop <- ungroup(trait.pop) %>% select(spepop, Trait, mean)
trait.pop <- pivot_wider(trait.pop, names_from = Trait, values_from = mean)
trait.pop <- select(trait.pop, 1, 3, 5, 8, 9, 11, 13, 14)
site.pop <- select(cov, 1, 2, 31) %>% left_join(long.pres, ., by = 'uniID')
#count uniID per site and month
counts <- site.pop %>% group_by(Site.x, month, uniID) %>% count()
counts <- counts %>% group_by(Site.x, month) %>% count()
site.pop <- site.pop %>% group_by(Site.x, month, species) %>% summarize(total = sum(count.bin))
site.pop <- left_join(site.pop, counts, by = c("Site.x", "month"))
site.pop <- mutate(site.pop, pit.abun = total/n)
site.pop <- select(site.pop, 1:3, 6)
site.pop$site.name <- paste(site.pop$Site.x, site.pop$month)
site.pop$spepop <- paste(site.pop$species, site.pop$Site.x)
site.pop <- site.pop %>% ungroup() %>% select(4:6)
wide.pop <- pivot_wider(site.pop, names_from = spepop, values_from = pit.abun)
wide.pop[is.na(wide.pop)] <- 0
sites <- wide.pop$site.name
#there are no trait measurements for species that are absent from a site
wide.pop <- ungroup(wide.pop) %>% select(-site.name)
wide.pop <- wide.pop[which(colSums(wide.pop) !=0)]
wide.pop <- cbind(sites, wide.pop)
row.names(wide.pop) <- wide.pop$sites
wide.pop <- select(wide.pop, -sites)
#check to ensure names are matched correctly between dataframes
spec <- colnames(wide.pop)
all.equal(spec, trait.pop$spepop)
trait.pop <- as.data.frame(trait.pop)
row.names(trait.pop) <- trait.pop$spepop
trait.pop <- select(trait.pop, -spepop)
fun <- dbFD(trait.pop, wide.pop, w.abun = TRUE)
fdis <- fun$FDis
fdis <- as.data.frame(cbind(fdis, sites))
cov$sites <- paste(cov$Site, cov$month)
fdis <- select(cov, 1:15, shrub.site, sites) %>% distinct() %>% left_join(fdis, by = "sites")
fdis$disp <- as.numeric(fdis$fdis)
ggplot(fdis, aes(esi, disp, color = month)) + geom_smooth(method = 'lm')
ggplot(fdis, aes(esi, disp, color = shrub.site)) + geom_smooth(method = 'lm')
View(cov)
ggplot(fdis, aes(site, esi)) + geom_boxplot()
ggplot(fdis, aes(Site, esi)) + geom_boxplot()
ggplot(fdis, aes(var.cover, disp)) + geom_smooth()
ggplot(fdis, aes(esi, disp)) + geom_smooth()
ggplot(fdis, aes(arid, disp)) + geom_smooth(method = 'lm')
cor.test(fdis$disp, fdis$arid)
ggplot(fdis, aes(Prec, disp)) + geom_smooth()
ggplot(fdis, aes(esi, disp)) + geom_smooth()
ggplot(fdis, aes(Temp, disp)) + geom_smooth()
ggplot(fdis, aes(Max, disp)) + geom_smooth()
ggplot(fdis, aes(var.cover, disp)) + geom_smooth()
library(picante)
View(wide.pop)
rep.is <- replicate(5, randomizeMatrix(wide.pop), null.model = "independentswap")
rep.is <- replicate(5, randomizeMatrix(wide.pop, null.model = "independentswap"))
typeof(rep.is)
df_list <- list(rep.is)
df <- as.data.frame(rep.is)
View(df)
View(trait.pop)
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = wide.pop, null.model = "independentswap")
simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom[, rep] <- simFDis
}
numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom <- matrix(NA, nrow = nrow(wide.pop), ncol = numberReps,
dimnames = list(rownames(wide.pop),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = wide.pop, null.model = "independentswap")
simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom[, rep] <- simFDis
}
View(randomizedFDis)
View(resultsRandom)
chk <- dbFD(trait.pop, wide.pop, w.abun = TRUE)$FDis
View(wide.pop)
View(fdis)
chk
obsFDis <- dbFD(trait.pop, wide.pop, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom, 1, sd)
SES3 <- ES3 / sdNull3
data.frame(SES, SES2, SES3)
data.frame(ES3)
SES_dis <- data.frame(ES3)
View(SES_dis)
View(fdis)
SES_dis$sites <- row.names(SES_dis)
SES <- select(cov, 1:15, shrub.site, sites) %>% distinct() %>% left_join(SES_dis, by = "sites")
ggplot(SES, aes(esi, ES3, color = shrub.site)) + geom_smooth(method = 'lm')
ggplot(SES, aes(arid, ES3)) + geom_smooth(method = 'lm')
cor.test(SES$ES3, SES$esi)
cor.test(SES$ES3, SES$arid)
cor.test(SES$ES3, SES$Temp)
cor.test(SES$ES3, SES$Max)
m1 <- glm(ES3 ~ Temp + esi + shrub.site, family = gaussian(), data = SES)
summary(m1)
ggplot(SES, aes(esi, ES3)) + geom_smooth(method = 'lm')
ggplot(SES, aes(var.cover, ES3)) + geom_smooth()
ggplot(SES, aes(esi, ES3)) + geom_smooth(method = 'lm')
ggplot(SES, aes(esi, ES3, color = month)) + geom_smooth(method = 'lm')
ggplot(SES, aes(mean.cover, ES3)) + geom_smooth(method = 'lm')
cor.test(SES$ES3, SES$mean.cover)
cor.test(SES$esi, SES$mean.cover)
View(SES)
cor.test(SES$ES3, SES$mean.height)
cor.test(SES$ES3, SES$var.height)
cor.test(SES$ES3, SES$var.cover)
SES <- mutate(SES, esi_rev = esi * -1)
ggplot(SES, aes(esi_rev, ES3)) + geom_smooth(method = 'lm')
cor.test(SES$arid, SES$esi)
ggplot(SES, aes(arid, esi)) + geom_smooth(method = 'lm')
ggplot(SES, aes(Max, ES3) + geom_smooth()
ggplot(SES, aes(Max, ES3)) + geom_smooth()
ggplot(SES, aes(Max, ES3)) + geom_smooth()
cor.test(SES$ES3, SES$arid)
cor.test(SES$ES3, SES$Temp)
cor.test(SES$ES3, SES$Max)
cor.test(SES$ES3, SES$mean.cover)
cor.test(SES$esi, SES$mean.cover)
cor.test(SES$ES3, SES$mean.height)
cor.test(SES$ES3, SES$var.cover)
m1 <- glmmTMB(ES3 ~ Temp + esi + shrub.site + (1|Site), family = gaussian(), data = SES)
summary(m1)
m1 <- glmmTMB(ES3 ~ Temp + esi + arid + (1|Site), family = gaussian(), data = SES)
summary(m1)
shapiro.test(resid(m1))
cor.test(SES$arid, SES$Temp)
m1 <- glmmTMB(ES3 ~ Temp + esi + (1|Site), family = gaussian(), data = SES)
summary(m1)
m1 <- glmmTMB(ES3 ~ arid + esi + (1|Site), family = gaussian(), data = SES)
summary(m1)
m1 <- glmmTMB(ES3 ~ arid*Temp + esi + (1|Site), family = gaussian(), data = SES)
summary(m1)
m1 <- glmmTMB(ES3 ~ arid+Temp + esi + mean.cover + (1|Site), family = gaussian(), data = SES)
summary(m1)
m1 <- glmmTMB(ES3 ~ arid+Temp + esi +  (1|Site), family = gaussian(), data = SES)
summary(m1)
m2 <- glmmTMB(ES3 ~ esi +  (1|Site), family = gaussian(), data = SES)
AIC(m1, m2)
m1 <- glmmTMB(ES3 ~ arid+Temp +(1|Site), family = gaussian(), data = SES)
m2 <- glmmTMB(ES3 ~ esi +  (1|Site), family = gaussian(), data = SES)
AIC(m1, m2)
m1 <- glmmTMB(ES3 ~ arid +(1|Site), family = gaussian(), data = SES)
m2 <- glmmTMB(ES3 ~ esi +  (1|Site), family = gaussian(), data = SES)
AIC(m1, m2)
m3 <- glmmTMB(ES3 ~ mean.cover + shrub.site + (1|Site), family = gaussian(), data = SES)
AIC(m1, m2, m3)
m2 <- glmmTMB(ES3 ~ esi*Temp +  (1|Site), family = gaussian(), data = SES)
summary(m2)
m2 <- glmmTMB(ES3 ~ esi+Temp +  (1|Site), family = gaussian(), data = SES)
summary(m2)
View(site.pop)
t.test(SES$ES3)
View(spe.bin)
View(trait.pop)
View(trait.pop)
View(traits.sp)
View(traits.wide)
View(trait.pop)
View(traits.spe)
View(traits.sp)
View(trait.pop)
View(traits.spe)
#for traits species should be rows, traits cols
traits.spe <- select(traits.sp, -sd)
traits.spe <- pivot_wider(traits.spe, names_from = Trait, values_from = mean)
#for traits species should be rows, traits cols
traits.spe <- select(traits.sp, -sd)
traits.spe <- pivot_wider(traits.spe, names_from = Trait, values_from = mean)
View(traits.spe)
traits.spe <- select(traits.spe, 1, 3,5,8, 9, 11, 13, 14)
View(traits.spe)
traits.spe <- rename(traits.spe, species = X.1)
traits.spe <- as.data.frame(traits.spe) %>% ungroup()
row.names(traits.spe) <- traits.spe$species
traits.spe <- select(traits.spe, -species)
View(traits.spe)
View(trait.pop)
numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom2 <- matrix(NA, nrow = nrow(spe.bin), ncol = numberReps,
dimnames = list(rownames(spe.bin),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = spe.bin, null.model = "independentswap")
simFDis <- dbFD(traits.spe, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom2[, rep] <- simFDis
}
View(spe.bin)
View(traits.spe)
#for traits species should be rows, traits cols
traits.spe <- select(traits.sp, -sd)
traits.spe <- pivot_wider(traits.spe, names_from = Trait, values_from = mean)
traits.spe <- select(traits.spe, 1, 3,5,8, 9, 11, 13, 14)
traits.spe <- rename(traits.spe, species = X.1)
traits.spe <- as.data.frame(traits.spe) %>% ungroup()
traits.spe$species <- gsub(" ", "", traits.spe$species)
row.names(traits.spe) <- traits.spe$species
traits.spe <- select(traits.spe, -species)
View(traits.spe)
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = spe.bin, null.model = "independentswap")
simFDis <- dbFD(traits.spe, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom2[, rep] <- simFDis
}
#remove zero rows
spe.bin <- spe.bin[rowSums(spe.bin) > 0]
#remove zero rows
spe.bin <- spe.bin[,rowSums(spe.bin) > 0]
#remove zero rows
spe.bin <- spe.bin[rowSums(spe.bin) > 0,]
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = spe.bin, null.model = "independentswap")
simFDis <- dbFD(traits.spe, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom2[, rep] <- simFDis
}
numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom2 <- matrix(NA, nrow = nrow(spe.bin), ncol = numberReps,
dimnames = list(rownames(spe.bin),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = spe.bin, null.model = "independentswap")
simFDis <- dbFD(traits.spe, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom2[, rep] <- simFDis
}
obsFDis <- dbFD(trait.pop, spe.bin, w.abun = TRUE)$FDis
obsFDis <- dbFD(traits.spe, spe.bin, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom2)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom2, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis_pit <- data.frame(ES3)
SES_dis_pit$sites <- row.names(SES_dis_pit)
mean(SES_dis_pit$ES3)
SES_dis_pit$uniID <- SES_dis_pit$sites
SES_pit <- left_join(SES_dis, cov, by = "sites")
ggplot(SES_dis_pit, aes(Microsite, ES3)) + geom_boxplot()
ggplot(SES_dis_pit, aes(microsite, ES3)) + geom_boxplot()
SES_pit <- left_join(SES_dis_pit, cov, by = "sites")
SES_pit <- left_join(SES_dis_pit, cov, by = "uniID")
ggplot(SES_dis_pit, aes(Microsite, ES3)) + geom_boxplot()
ggplot(SES_dis_pit, aes(microsite, ES3)) + geom_boxplot()
View(SES_dis_pit)
ggplot(SES_pit, aes(microsite, ES3)) + geom_boxplot()
ggplot(SES_pit, aes(Microsite, ES3)) + geom_boxplot()
m1 <- glmmTMB(ES3 ~ esi + 1(Site), family = "gaussian", data = SES_pit)
m1 <- glmmTMB(ES3 ~ esi + (1|Site), family = "gaussian", data = SES_pit)
summary(m1)
View(SES_pit)
m1 <- glmmTMB(ES3 ~ esi + Microsite+ dry.veg.percent + (1|Site), family = "gaussian", data = SES_pit)
summary(m1)
m1 <- glmmTMB(ES3 ~ esi + Microsite+ dry.veg.percent + arid + (1|Site), family = "gaussian", data = SES_pit)
summary(m1)
m1 <- glmmTMB(ES3 ~ esi + Microsite+ dry.veg.percent + arid + month + shrub.site+ (1|Site), family = "gaussian", data = SES_pit)
summary(m1)
t.test(SES_pit$ES3, SES_pit$Microsite)
t.test(SES_pit$ES3~ SES_pit$Microsite)
m1 <- glmmTMB(ES3 ~ esi * Microsite+ dry.veg.percent + arid + month + shrub.site+ (1|Site), family = "gaussian", data = SES_pit)
summary(m1)
ggplot(SES_pit, aes(esi, ES3, color = Microsite)) + geom_smooth(method = "lm")
ggplot(SES_pit, aes(esi, ES3, color = shrub.site)) + geom_smooth(method = "lm")
m2 <- glmmTMB(Species ~ esi * Microsite+ dry.veg.percent + arid + month + shrub.site+ (1|Site), family = "poisson", data = SES_pit)
summary(m2)
m2 <- glmmTMB(Species ~ esi + Microsite+ dry.veg.percent + arid + month + shrub.site+ (1|Site), family = "poisson", data = SES_pit)
summary(m2)
m2 <- glmmTMB(Species ~ esi + Microsite+ dry.veg.percent  + month + shrub.site+ (1|Site), family = "poisson", data = SES_pit)
summary(m2)
m2 <- glmmTMB(Species ~ esi + Microsite+ arid + dry.veg.percent  +  shrub.site+ (1|Site), family = "poisson", data = SES_pit)
summary(m2)
m2 <- glmmTMB(Species ~ esi + Microsite+ arid + dry.veg.percent  +  shrub.site+ (1|Site) + (1|month), family = "poisson", data = SES_pit)
summary(m2)
m2 <- glmmTMB(Species ~ esi + Microsite* arid + dry.veg.percent  +  shrub.site+ (1|Site) + (1|month), family = "poisson", data = SES_pit)
summary(m2)
m2 <- glmmTMB(Species ~ esi + Microsite+ arid + dry.veg.percent  +  shrub.site+ (1|Site) + (1|month), family = "poisson", data = SES_pit)
m2 <- glmmTMB(Species ~ esi + Microsite+ arid + dry.veg.percent  +  shrub.site+ mean.cover + (1|Site) + (1|month), family = "poisson", data = SES_pit)
summary(m2)
m1 <- glmmTMB(ES3 ~ ~ esi + Microsite+ arid + dry.veg.percent  +  shrub.site+ mean.cover + (1|Site) + (1|month), family = "gaussian", data = SES_pit)
m1 <- glmmTMB(ES3 ~ esi + Microsite+ arid + dry.veg.percent  +  shrub.site+ mean.cover + (1|Site) + (1|month), family = "gaussian", data = SES_pit)
summary(m1)
shapiro.test(resid(m1))
plot(resid(m1))
plot(resid(m1))
plot(m1)
