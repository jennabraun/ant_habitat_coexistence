# plot(xi, xlab = "Number of Individuals", ylab = "Species Richness")
plot(xs, xlab = "Number of Pitfall Samples", ylab = "Species Richness", cex.lab = 1.5)
title("Silver Creek Ranch", adj = 0)
library(dplyr)
library(tidyr)
library(ggplot2)
library(performance)
library(glmmTMB)
library(vegan)
library(ggvegan)
library(FD)
library(picante)
library(gridExtra)
# Chunk 1: setup
library(dplyr)
library(tidyr)
library(ggplot2)
library(performance)
library(glmmTMB)
library(vegan)
library(ggvegan)
library(FD)
library(picante)
library(gridExtra)
# Chunk 2
multiple.func <- function(x) {
c(mean = mean(x), sd = sd(x))}
# Chunk 3
#see Cleaning.R in scripts folder for data cleaning
wide <- read.csv("Clean Data/ants_wide.csv")
cov <- read.csv("Clean Data/ants.csv")
site_data <- read.csv("Clean Data/sites_joined.csv")
cov <- right_join(site_data, cov, by = c("Site", "month"))
cov <- dplyr::select(cov, 3:10, 14:19, 22:36, 39:41)
#total count of ants
sum(cov$abun)
#add ecostress sensor data
eco <- read.csv("Clean Data/ecostress.csv")
eco <- select(eco, 1, 2, 11)
eco <- rename(eco, month = Category, Site = ID, esi = ECO4ESIPTJPL_001_Evaporative_Stress_Index_PT_JPL_ESIavg)
cov <- right_join(eco, cov, by = c("Site", "month"))
#read in foundation plant identity for the sites
shrubs <- read.csv("Clean Data/shrubs.csv")
cov <- right_join(cov, shrubs, by = "Site")
cov$shrub.site <- as.factor(cov$shrub.site)
#read in ndvi and soil data
ndvi <- read.csv("raw data/sites_remotesensing.csv")
ndvi <- select(ndvi, 7:17) %>%
rename(Site = site)
ndvi$Site <- gsub("MoV", "Mov", ndvi$Site)
cov <- right_join(cov, ndvi, by = c("Site", "month"))
cov$sites <- paste(cov$Site, cov$month)
# Chunk 4
#cleaning the raw trait data
traits <- read.csv("raw data/Traits.csv")
#check for spelling mistakes in trait labels
unique(traits$Trait)
#I don't trust the eye width measurements because they were measured from the front
traits <- filter(traits, Trait != "Eye width")
#unique(traits$Photo)
#extract site IDs from photo names
traits <- separate(traits, Photo, c("Site", "Slide", "Specimen"))
traits$Site <- gsub("Papl", "PaPl", traits$Site)
unique(traits$Site)
traits <- traits[-1,]
#remove the double pheidole entry
traits <- traits[-2,]
#need to divide the trait values by weber's body length. I want to do this at the individual level, not dividing means by mean webers
traits <- select(traits, -X, -Label)
traits <- pivot_wider(traits, names_from = Trait, values_from = Measure)
traits <- mutate(traits, Femur.w = Femur/Webers, Scape.w = Scape/Webers, Mandible.w = `Mandible length`/Webers, Headl.w = `Head length`/Webers, Eyel.w = `Eye length`/Webers, Headw.w = `Head width`/Webers)
traits <- pivot_longer(traits, 5:17, names_to = "Trait", values_to = "Measure")
#check for ant species name typoes
unique(traits$X.1)
#some traits are NA because of damage to the specimen
traits <- drop_na(traits)
#calculate the mean value of the trait for each species at each site (population level trait values)
traits.ag <- group_by(traits, Site, X.1, Trait) %>%
summarise(mean = mean(Measure), sd = sd(Measure))
#create a data frame of the mean values for each species across all sites (species level trait values)
traits.sp <- group_by(traits, X.1, Trait) %>%
summarise(mean = mean(Measure), sd = sd(Measure))
# Chunk 5
#convert to presence absence
long.pres <- pivot_longer(wide, 2:14, names_to = "species", values_to = "count")
long.pres <- mutate(long.pres, count.bin = ifelse(count >= 1, 1, 0))
#get total abundance per trap
long.pres <- group_by(long.pres, uniID) %>%
mutate(total = sum(count.bin))
#calculate relative abundances
long.pres <- long.pres %>% mutate(rel.abun = count.bin/total)
traits.ag <- rename(traits.ag, species = X.1)
traits.ag$species <- gsub(" ", "", traits.ag$species)
#add sites to long
long.pres <- cov %>% select(Site, uniID) %>% right_join(long.pres, . , by = 'uniID')
#this adds NA traits to 0 abundances - species isn't found at pitfall or site
# Chunk 6
#make a presence/absence pitfall trap data frame
spe.bin <- long.pres
spe.bin <- select(spe.bin, 2, 3, 5)
spe.bin <- pivot_wider(spe.bin, names_from = species, values_from = count.bin)
spe.bin <- select(spe.bin, -11, -12)
# Chunk 7
# I want the PCA on traits
# make it wide again
traits.wide <- pivot_wider(traits, names_from = Trait, values_from = Measure)
#keep only weber lengthh standardized traits
traits.wide <- select(traits.wide, 11:17)
traits.wide <- drop_na(traits.wide)
traits.st <- decostand(traits.wide, method = "standardize")
traits.pca <- rda(traits.st)
#summary(traits.pca)
biplot(traits.pca, xlab = "PCA 33.9%", ylab = "PCA 32.9%")
#PC3 is ~15%
# Chunk 8
trait.pop <- traits.ag
trait.pop$spepop <- paste(trait.pop$species, trait.pop$Site)
trait.pop <- ungroup(trait.pop) %>% select(spepop, Trait, mean)
trait.pop <- pivot_wider(trait.pop, names_from = Trait, values_from = mean)
trait.pop <- select(trait.pop, 1, 3, 5, 8, 9, 11, 13, 14)
trait.pop.st <- select(trait.pop, -1) %>% decostand(method = "standardize")
#rename the column names for the figure
colnames(trait.pop.st) <- c("Eye length", "Femur length", "Head \n length", "Head\n Width", "Mandible\n length", "Scape length", "Weber's \nbody length")
trait.pop.pca <- rda(trait.pop.st)
summary(trait.pop.pca)
pcplot1 <- autoplot(trait.pop.pca, xlab = "PCA Axis 1 (35.8%)", ylab = "PCA Axis 2 (32.2%)") +  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_rect(colour = "black", size=1, fill = NA), axis.line = element_line(colour = "black")) + theme(legend.position = "none")  + xlim(-1.5, 1.8)
pcplot1
#PCA3 ~ 16%
# Chunk 9
env2 <- select(cov, 3:5, 8, 12:15, 37:43, sites) %>% drop_na() %>% distinct()
env2_sitelabels <- env2$sites
env2 <- select(env2, -sites)
#standardize to mean of zero etc
env.d2 <- decostand(env2, method = "standardize")
env.pca2 <- rda(env.d2)
a <- summary(env.pca2)
b <- a$cont$importance
prop1 <- b[2,1] * 100
prop1 <- round(prop1, digits = 2)
prop2 <- b[2,2] * 100
prop2 <- round(prop2, digits = 2)
#summary(env.pca2)
#autoplot(env.pca2, xlab = paste("PCA", prop1), ylab = paste("PCA", prop2))
#sitescores <- scores(env.pca2, c(1,2, 3), 'sites')
envreduce <- select(env2, -esi, -arid, -10, -12, -13, -14)
env.reduce <- decostand(envreduce, method = "standardize")
colnames(env.reduce) <- c("Mean Cover", "Variation Cover", "Mean Veg Height", "Mean Annual \n Temperature", "Mean Annual Precipitation", "Maximum \n Temperature", "NDVI", "Mean Soil Temp", "Range Soil Temp")
env.pcareduce <- rda(env.reduce)
a <- summary(env.pcareduce)
b <- a$cont$importance
prop1 <- b[2,1] * 100
prop1 <- round(prop1, digits = 2)
prop2 <- b[2,2] * 100
prop2 <- round(prop2, digits = 2)
summary(env.pcareduce)
pcplot2 <- autoplot(env.pcareduce , xlab = paste("PCA Axis 1 (", prop1, "%)", sep = ""), ylab = paste("PCA Axis 2 (", prop2, "%)", sep = "")) + xlim(-1.5, 1.6) +  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_rect(colour = "black", size=1, fill = NA), axis.line = element_line(colour = "black")) + theme(legend.position = "none")
pcplot2
sitescores <- scores(env.pcareduce, c(1,2, 3), 'sites')
sitescores <- as.data.frame(cbind(sitescores, env2_sitelabels))
# Chunk 10
#Figure 2
gA <- ggplotGrob(pcplot1)
gB <- ggplotGrob(pcplot2)
grid::grid.newpage()
grid::grid.draw(rbind(gA, gB))
# Chunk 11
#need a species by trait matrix, but I want to use the population means
#make species name the name + site
site.pop <- select(cov, 1, 2, 31) %>% left_join(long.pres, ., by = 'uniID')
#count uniID per site and month
counts <- site.pop %>% group_by(Site.x, month, uniID) %>% count()
counts <- counts %>% group_by(Site.x, month) %>% count()
site.pop <- site.pop %>% group_by(Site.x, month, species) %>% summarize(total = sum(count.bin))
site.pop <- left_join(site.pop, counts, by = c("Site.x", "month"))
site.pop <- mutate(site.pop, pit.abun = total/n)
site.pop <- select(site.pop, 1:3, 6)
site.pop$site.name <- paste(site.pop$Site.x, site.pop$month)
site.pop$spepop <- paste(site.pop$species, site.pop$Site.x)
site.pop <- site.pop %>% ungroup() %>% select(4:6)
wide.pop <- pivot_wider(site.pop, names_from = spepop, values_from = pit.abun)
wide.pop[is.na(wide.pop)] <- 0
sites <- wide.pop$site.name
#there are no trait measurements for species that are absent from a site
wide.pop <- ungroup(wide.pop) %>% select(-site.name)
wide.pop <- wide.pop[which(colSums(wide.pop) !=0)]
wide.pop <- cbind(sites, wide.pop)
row.names(wide.pop) <- wide.pop$sites
wide.pop <- select(wide.pop, -sites)
#remove the two solenopsis singletons - no trait measuremnts
wide.pop <- select(wide.pop, -36, -42)
#check to ensure names are matched correctly between dataframes
spec <- colnames(wide.pop)
trait.pop <- as.data.frame(trait.pop)
row.names(trait.pop) <- trait.pop$spepop
trait.pop <- select(trait.pop, -spepop)
all.equal(spec, row.names(trait.pop))
# Chunk 12
#Lets create a matrix to store results from each iteration (one column per iteration)
#saving the randomization as an R object to cut down knit time
# numberReps <- 100
# resultsRandom <- matrix(NA, nrow = nrow(wide.pop), ncol = numberReps,
#                         dimnames = list(rownames(wide.pop),
#                                         paste0("Sim.", 1:numberReps)))
# for(rep in 1:numberReps){
#   randomizedFDis <- randomizeMatrix(samp = wide.pop, null.model = "independentswap")
#   simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
#   resultsRandom[, rep] <- simFDis
# }
#saveRDS(resultsRandom, file = "Clean Data/objects/FDispRandom_sites.rds")
# Chunk 13
resultsRandom <- readRDS("Clean Data/objects/FDispRandom_sites.rds")
obsFDis <- dbFD(trait.pop, wide.pop, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis <- data.frame(SES3)
SES_dis$sites <- row.names(SES_dis)
#make random values negative
resultsRandom_neg <- resultsRandom * -1
diff <- sweep(resultsRandom_neg, 1, obsFDis, "+")
diff_ses <- sweep(diff, 1, meanNull3, "/")
diff_ses_ag <- apply(diff_ses, 1, multiple.func)
diff_ses_ag <- t(diff_ses_ag)
diff_ses_ag <- cbind(diff_ses_ag, SES_dis$sites)
#get rid of last row
diff_ses_ag <- head(diff_ses_ag, 27)
test <- cbind(sdNull3, diff_ses_ag)
test <- as.data.frame(test)
test$sd <- as.numeric(test$sd)
test <- rename(test, sdrand = sdNull3)
test$sdrand <- as.numeric(test$sdrand)
cor.test(test$sd, test$sdrand)
#variation in SES values is the same as the random variation in fdisp calculated from a null model
#join site-level environmental measurements to data
cov$sites <- paste(cov$Site, cov$month)
SES <- select(cov, 1:15, shrub.site, sites, 37:43) %>% distinct() %>% left_join(SES_dis, by = "sites")
# Chunk 14
SES2 <- cbind(SES, sitescores)
SES2$PC1 <- as.numeric(SES2$PC1)
SES2$PC2 <- as.numeric(SES2$PC2)
SES2$PC3 <- as.numeric(SES2$PC3)
#need to add raw FDisp score
mean(SES$SES3)
t.test(SES$SES3)
library(glmmTMB)
m1 <- glmmTMB(SES3 ~  PC1 + PC2 + (1|Site), data = SES2)
summary(m1)
m1 <- lm(SES3 ~  PC1 + PC2 , data = SES2)
fit1 <- lm(SES3 ~  PC1, data = SES2)
summary(fit1)
ggplot(SES2, aes(PC1, SES3)) + geom_point() + stat_smooth(method = "lm") + xlab("PC1") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_rect(colour = "black", size=1, fill = NA), axis.line = element_line(colour = "black")) + ylab("SES Functional dispersion")+  geom_label(aes(x = 0.75, y = 2),vjust=1, hjust = 0,
label = paste("Adj r2 = ",signif(summary(fit1)$adj.r.squared, 3),
" \nP =",signif(summary(fit1)$coef[2,4], 3))) + geom_hline(yintercept = 0, linetype = "dashed")
SES2 <- mutate(SES2, shrub = ifelse(shrub.site == "atriplex", "shrub", (ifelse(shrub.site == "ephedra", "shrub", "open"))))
m <- lm(SES3 ~  shrub, data = SES2)
summary(m)
SES2 %>% group_by(shrub) %>% summarize(mean = mean(SES3), sd = sd(SES3))
#new heat map
mat3 <- select(SES2, esi, 4,5, 8, 12:15, 18, 24, 24:28)
M3 <- cor(mat3)
corrplot::corrplot(M3, method = "number")
# Chunk 15
library(adespatial)
library(SoDA)
#convert our degrees in lat long to cartesian
sites.xy <- geoXY(SES2$Lat.x, SES2$Long.x)
mem <- dbmem(sites.xy)
var_df <- cbind(SES2, sites.xy)
disp <- SES2$SES3
env <- select(SES2, 4, 5, 8, 12:14, 18, 19, 24)
v1 <- varpart(Y =disp, X = env, sites.xy)
summary(v1)
#showvarparts(v1)
plot(v1)
#rda(v1)
#use long pres
#join month by identifier
#remove the two singletons?
alpha <- select(cov, uniID, month) %>% right_join(long.pres, by = "uniID")
alpha$sites <- paste(alpha$Site, alpha$month)
alpha <- filter(alpha, species != "Solenopsisaurea" & species != "Solenopsismolesta")
alpha <- select(alpha, sites, species, count.bin)
alpha <- distinct(alpha)
alpha <- alpha %>% group_by(sites) %>% summarise(richness = sum(count.bin))
alpha <- right_join(alpha, SES2, by = "sites")
#same GLM or GLMM
m1 <- glmmTMB(richness ~ PC1 + PC2 +  (1|Site), family = "poisson", data = alpha)
summary(m1)
m2 <- glm(richness ~ Prec, family = "poisson", data = alpha)
summary(m2)
m3 <- glm(richness ~ month, family = "poisson", data = alpha)
summary(m3)
car::Anova(m3)
tb <- table(alpha$richness, alpha$sites)
chisq.test(alpha$richness, alpha$Site)
check_overdispersion(m1)
#same GLM or GLMM
m1 <- glmmTMB(richness ~ PC1 + PC2 +  (1|Site), family = "poisson", data = alpha)
summary(m1)
m2 <- glm(richness ~ Prec, family = "poisson", data = alpha)
summary(m2)
m2 <- glm(richness ~ PC1 + PC2, family = "poisson", data = alpha)
summary(m2)
AIC(m1, m2)
m2 <- glmmTMB(richness ~ PC1 + PC2, family = "poisson", data = alpha)
summary(m2)
AIC(m1, m2)
summary(m1)
m1 <- glmmTMB(SES3 ~  PC1 + PC2 + (1|Site), data = SES2)
summary(m1)
m2 <- glmmTMB(SES3 ~  PC1 + PC2, data = SES2)
summary(m2)
AIC(m1, m2)
#functional indices are weighted so use abundance weighted beta-diversity
library(betapart)
# baselgi methods for beta-diversity
#we can use the occupancy population dateframe
#drop half of species name after space
#filter out two singletons
sites_species <- site.pop
sites_species <- separate(sites_species, spepop, into = c("species", "month"), sep = " ")
sites_species <- filter(sites_species, species != "Solenopsisaurea" & species != "Solenopsismolesta")
sites_species <- select(sites_species, -month)
# need wide
sites_species <- pivot_wider(sites_species, names_from = "species", values_from = "pit.abun") %>% as.data.frame()
row.names(sites_species) <- sites_species$site.name
sites_species <- select(sites_species, -site.name)
#balanced variation in abundance is turnover
#abundance gradients are nestedness
beta.core <- betapart.core.abund(sites_species)
betapair <- beta.pair.abund(beta.core)
betamulti <- beta.multi.abund(beta.core)
#turnover component
betamulti$beta.BRAY.BAL
#nestedness component
betamulti$beta.BRAY.GRA
#combined
betamulti$beta.BRAY
#mostly turnover, some nestedness
#betapair are dist objects
tdis <- betapair$beta.bray.bal
ndis <- betapair$beta.bray.gra
#let's use the standardized environmental variables from the pca scores
envbeta <- cbind(env.reduce, env2_sitelabels)
#sort envbeta to same order as site_species
envbeta <- envbeta[order(match(envbeta[,10], row.names(sites_species))),]
row.names(envbeta) <- envbeta$env2_sitelabels
envbeta <- select(envbeta, -env2_sitelabels)
env_dist <- dist(envbeta, "euclidean")
mantel(tdis, env_dist)
mantel(ndis, env_dist)
#turnover NOT related to env gradient
#nestedness - this is changes to abundance is related
#can I do mean at each site and plot against environment?
site_cwm <- dbFD(trait.pop, wide.pop, w.abun = TRUE)$CWM
cwm <- site_cwm
cwm$sites <- row.names(cwm)
cwm <- select(SES2, sites, PC1, PC2, PC3) %>% left_join(cwm, by = 'sites')
fit1 <- glmmTMB(Webers ~ PC1, cwm)
summary(fit1)
fit2 <- glmmTMB(Webers ~ PC1 + (1|Site), cwm)
View(cwm)
site_cwm <- dbFD(trait.pop, wide.pop, w.abun = TRUE)$CWM
cwm <- site_cwm
cwm$sites <- row.names(cwm)
m1 <- glmmTMB(SES3 ~  PC1 + PC2 + (1|Site), data = SES2)
summary(m1)
m2 <- glmmTMB(SES3 ~  PC1 + PC2, data = SES2)
summary(m2)
View(wide.pop)
View(wide.pop)
View(site_data)
View(SES)
View(SES2)
cwm <- select(SES2, Site, sites, PC1, PC2, PC3) %>% left_join(cwm, by = 'sites')
fit2 <- glmmTMB(Webers ~ PC1 + (1|Site), cwm)
summary(fit2)
AIC(fit1, fit2)
a <- ggplot(fit2$model, aes_string(x = names(fit2$model)[2], y = names(fit2$model)[1])) +
geom_point() +
stat_smooth(method = "lm", col = "blue") +
geom_label(aes(x = 0.75, y = 1.4),vjust=1, hjust = 0,
label = paste("Adj r2 = ",signif(summary(fit2)$adj.r.squared, 3),
" \nP =",signif(summary(fit1)$coef[2,4], 3))) + ylab("CWM Weber's \nBody Length (mm)") + xlab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))  + theme(plot.margin=grid::unit(c(0,0,0,0), "mm")) + theme(text = element_text(size = 18))
a
a <- ggplot(fit2$model, aes_string(x = names(fit2$model)[2], y = names(fit2$model)[1])) +
geom_point() +
stat_smooth(method = "lm", col = "blue") +
geom_label(aes(x = 0.75, y = 1.4),vjust=1, hjust = 0,
label = paste("Adj r2 = ",signif(summary(fit2)$adj.r.squared, 3),
" \nP =",signif(summary(fit1)$coef[2,4], 3))) + ylab("CWM Weber's \nBody Length (mm)") + xlab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))  + theme(plot.margin=grid::unit(c(0,0,0,0), "mm")) + theme(text = element_text(size = 18))
a <- ggplot(fit1$model, aes_string(x = names(fit1$model)[2], y = names(fit1$model)[1])) +
geom_point() +
stat_smooth(method = "lm", col = "blue") +
geom_label(aes(x = 0.75, y = 1.4),vjust=1, hjust = 0,
label = paste("Adj r2 = ",signif(summary(fit1)$adj.r.squared, 3),
" \nP =",signif(summary(fit1)$coef[2,4], 3))) + ylab("CWM Weber's \nBody Length (mm)") + xlab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))  + theme(plot.margin=grid::unit(c(0,0,0,0), "mm")) + theme(text = element_text(size = 18))
fit1 <- lm(Webers ~ PC1, cwm)
a <- ggplot(fit1$model, aes_string(x = names(fit1$model)[2], y = names(fit1$model)[1])) +
geom_point() +
stat_smooth(method = "lm", col = "blue") +
geom_label(aes(x = 0.75, y = 1.4),vjust=1, hjust = 0,
label = paste("Adj r2 = ",signif(summary(fit1)$adj.r.squared, 3),
" \nP =",signif(summary(fit1)$coef[2,4], 3))) + ylab("CWM Weber's \nBody Length (mm)") + xlab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))  + theme(plot.margin=grid::unit(c(0,0,0,0), "mm")) + theme(text = element_text(size = 18))
a
a <- ggplot(fit2$frame, aes_string(x = names(fit2$frame)[2], y = names(fit2$frame)[1])) +
geom_point() +
stat_smooth(method = "lm", col = "blue")
a
summary(fit2)
Summary(fit2)$adj.r.squared
model_performance(fit2)
#same GLM or GLMM
m1 <- glmmTMB(richness ~ PC1 + PC2 +  (1|Site), family = "poisson", data = alpha)
summary(m1)
m1 <- glmmTMB(SES3 ~  PC1 + PC2 + (1|Site), data = SES2)
summary(m1)
m1 <- glmmTMB(SES3 ~  PC1 + PC2 + shrub + (1|Site), data = SES2)
summary(m1)
m <- lm(SES3 ~  shrub + 1(|Site), data = SES2)
m <- glmmTMB(SES3 ~shrub + 1(|Site), data = SES2)
m <- glmmTMB(SES3 ~shrub + (1|Site), data = SES2)
summary(m)
traits.sp1 <- traits.sp %>%
select(.,-sd) %>%
pivot_wider(names_from = Trait, values_from = mean) %>%
as.data.frame(traits.sp)
traits.sp1 <- select(traits.sp1, 1, 3, 5, 8, 9, 11, 13, 14)
traits.sp1$X.1 <- gsub(" ", ".", traits.sp$X.1)
species.name <- traits.sp$X.1
View(traits.sp)
species.name <- traits.sp$X.1
#gower dissimilarity?
gow <- gowdis(traits.sp)
overdis <- readRDS(file = "Clean Data/objects/overlap_dissim.rds")
View(overdis)
traits.sp <- select(traits.sp, -X.1)
traits.sp1$X.1 <- gsub(" ", ".", traits.sp1$X.1)
View(traits.sp1)
species.name <- traits.sp1$X.1
traits.sp1 <- select(traits.sp1, -X.1)
#gower dissimilarity?
gow <- gowdis(traits.sp1)
gow <- as.matrix(gow)
mantel(gow, overdis)
a <- mantel(gow, overdis)
plot(a)
Plots(a)
View(gow)
View(traits.sp1)
traits.sp1 <- traits.sp %>%
select(.,-sd) %>%
pivot_wider(names_from = Trait, values_from = mean) %>%
as.data.frame(traits.sp)
traits.sp1 <- select(traits.sp1, 1, 3, 5, 8, 9, 11, 13, 14)
traits.sp1$X.1 <- gsub(" ", ".", traits.sp1$X.1)
species.name <- traits.sp1$X.1
traits.sp1 <- select(traits.sp1, -X.1)
#gower dissimilarity?
gow <- gowdis(traits.sp1)
install.packages("harrietr")
#save overlap as an object
overdis <- harrietr::melt_dist(overdis)
install.packages("ggtree")
BiocManager::install("ggtree")
xy <- t(combn(colnames(overdis), 2))
data.frame(xy, dist=m[xy])
View(xy)
install.packages("reshape2")
install.packages("reshape2")
b <- subset(melt(overdis), value !=0)
library(reshape2)
b <- subset(melt(overdis), value !=0)
View(b)
two <- readRDS(file = "Clean Data/objects/predictionrasters.rds")
overlap <- calc.niche.overlap(two, overlapStat = "D")
#ant SDMs
#tutorial from vignette
# Load packages -- the order here is important because some pkg functions overwrite others.
library(ENMeval)
overlap <- calc.niche.overlap(two, overlapStat = "D")
View(overdis)
View(overlap)
testover <- 1 - overlap
View(testover)
testover <- testover[,order(colnames(testover))]
testover <- testover[order(row.names(testover)),]
View(overdis)
a
gow1 <- lower.tri(gow)
overdis1 <- lower.tri(overdis)
View(gow1)
gow1 <- gow[lower.tri(gow)]
overdis1 <- overdis[lower.tri(overdis)]
mantel(gow1, overdis1)
gow1 <- as.matrix(gow1)
View(overdis)
mantel(gow, overdis)
gow1 <- as.matrix(gow)
gow1 <- gow1[lower.tri(gow1)]
mantel(gow, overdis)
mantel(gow, overdis1)
overdis1 <- as.dist(overdis1)
mantel(gow, overdis1)
overdis1 <- as.dist(overdis)
mantel(gow, overdis1)
