#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom <- matrix(NA, nrow = nrow(wide.pop), ncol = numberReps,
dimnames = list(rownames(wide.pop),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = wide.pop, null.model = "independentswap")
simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom[, rep] <- simFDis
}
obsFDis <- dbFD(trait.pop, wide.pop, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis <- data.frame(ES3)
SES_dis$sites <- row.names(SES_dis)
#join site-level environmental measurements to data
cov$sites <- paste(cov$Site, cov$month)
SES <- select(cov, 1:15, shrub.site, sites) %>% distinct() %>% left_join(SES_dis, by = "sites")
#for traits species should be rows, traits cols
traits.spe <- select(traits.sp, -sd)
traits.spe <- pivot_wider(traits.spe, names_from = Trait, values_from = mean)
traits.spe <- select(traits.spe, 1, 3,5,8, 9, 11, 13, 14)
traits.spe <- rename(traits.spe, species = X.1)
traits.spe <- as.data.frame(traits.spe) %>% ungroup()
traits.spe$species <- gsub(" ", "", traits.spe$species)
row.names(traits.spe) <- traits.spe$species
traits.spe <- select(traits.spe, -species)
row.names(spe.bin) <- spe.bin$uniID
#remove zero rows
spe.bin <- spe.bin[rowSums(spe.bin) > 0,]
spe.bin <- select(spe.bin, -uniID)
#remove zero rows
spe.bin <- spe.bin[rowSums(spe.bin) > 0,]
---
title: Ants species coexistence
output:
rmdformats::readthedown:
collapsed: false
highlight: kate
---
```{r setup}
library(dplyr)
library(tidyr)
library(ggplot2)
library(performance)
library(glmmTMB)
library(ade4)
library(nlme)
library(ape)
library(vegan)
library(ggvegan)
#library(TPD)
```
```{r}
#see Cleaning.R in scripts folder for data cleaning
wide <- read.csv("Clean Data/ants_wide.csv")
cov <- read.csv("Clean Data/ants.csv")
sites <- read.csv("Clean Data/sites_joined.csv")
cov <- right_join(sites, cov, by = c("Site", "month"))
cov <- dplyr::select(cov, 3:10, 14:19, 22:36, 39:41)
#total count of ants
sum(cov$abun)
#add ecostress sensor data
eco <- read.csv("Clean Data/ecostress.csv")
eco <- select(eco, 1, 2, 11)
eco <- rename(eco, month = Category, Site = ID, esi = ECO4ESIPTJPL_001_Evaporative_Stress_Index_PT_JPL_ESIavg)
cov <- right_join(eco, cov, by = c("Site", "month"))
#read in foundation plant identity for the sites
shrubs <- read.csv("Clean Data/shrubs.csv")
cov <- right_join(cov, shrubs, by = "Site")
cov$shrub.site <- as.factor(cov$shrub.site)
```
```{r}
#cleaning the raw trait data
traits <- read.csv("raw data/Traits.csv")
#check for spelling mistakes in trait labels
unique(traits$Trait)
#I don't trust the eye width measurements because they were measured from the front
traits <- filter(traits, Trait != "Eye width")
unique(traits$Photo)
#extract site IDs from photo names
traits <- separate(traits, Photo, c("Site", "Slide", "Specimen"))
traits$Site <- gsub("Papl", "PaPl", traits$Site)
unique(traits$Site)
traits <- traits[-1,]
#remove the double pheidole entry
traits <- traits[-2,]
#need to divide the trait values by weber's body length. I want to do this at the individual level, not dividing means by mean webers
traits <- select(traits, -X, -Label)
traits <- pivot_wider(traits, names_from = Trait, values_from = Measure)
traits <- mutate(traits, Femur.w = Femur/Webers, Scape.w = Scape/Webers, Mandible.w = `Mandible length`/Webers, Headl.w = `Head length`/Webers, Eyel.w = `Eye length`/Webers, Headw.w = `Head width`/Webers)
traits <- pivot_longer(traits, 5:17, names_to = "Trait", values_to = "Measure")
#check for ant species name typoes
unique(traits$X.1)
#some traits are NA because of damage to the specimen
traits <- drop_na(traits)
#calculate the mean value of the trait for each species at each site (population level trait values)
traits.ag <- group_by(traits, Site, X.1, Trait) %>%
summarise(mean = mean(Measure), sd = sd(Measure))
#create a data frame of the mean values for each species across all sites (species level trait values)
traits.sp <- group_by(traits, X.1, Trait) %>%
summarise(mean = mean(Measure), sd = sd(Measure))
```
## CWM - Presence/absence
```{r}
#we could also try to log transform the abundances to reduce the impact of colony size
#this is presence absence
long.pres <- pivot_longer(wide, 2:14, names_to = "species", values_to = "count")
long.pres <- mutate(long.pres, count.bin = ifelse(count >= 1, 1, 0))
spe.bin <- long.pres
#get total abundance per trap
long.pres <- group_by(long.pres, uniID) %>%
mutate(total = sum(count.bin))
#calculate relative abundances
long.pres <- long.pres %>% mutate(rel.abun = count.bin/total)
traits.ag <- rename(traits.ag, species = X.1)
traits.ag$species <- gsub(" ", "", traits.ag$species)
#add sites to long
long.pres <- cov %>% select(Site, uniID) %>% right_join(long.pres, . , by = 'uniID')
#this adds NA traits to 0 abundances - species isn't found at pitfall or site
join.right <- right_join(traits.ag, long.pres, by = c("Site", "species"))
#join.left <- left_join(traits.ag, long, by = c("Site", "species"))
CWM.pres <- mutate(join.right, cwm.prod = mean*rel.abun)
CWM.pres <- group_by(CWM.pres, Site, uniID, Trait) %>% summarise(cwm = sum(cwm.prod))
#join environmental data to CWM trait dataframe
CWM.pres <- left_join(CWM.pres, cov, by = "uniID")
```
```{r}
#make a presence/absence pitfall trap data frame
spe.bin <- select(spe.bin, 2, 3, 5)
spe.bin <- pivot_wider(spe.bin, names_from = species, values_from = count.bin)
spe.bin <- select(spe.bin, -11, -12)
```
# EDA
## Heat Map
```{r}
mat <- pivot_wider(CWM.pres, names_from = Trait, values_from = cwm)
mat <- select(mat, 6:11, 14:17, 25:29, 31, 33, 34, 36, 38, 41, 42, 44, 46, 47) %>% ungroup()
mat <- ungroup(mat) %>% select(-uniID)
mat <- drop_na(mat)
#str(mat)
M <- cor(mat)
corrplot::corrplot(M, method = "number")
```
## PCA for traits
### Invidividuals
```{r}
# I want the PCA on traits
# make it wide again
traits.wide <- pivot_wider(traits, names_from = Trait, values_from = Measure)
#keep only weber lengthh standardized traits
traits.wide <- select(traits.wide, 11:17)
traits.wide <- drop_na(traits.wide)
traits.st <- decostand(traits.wide, method = "standardize")
traits.pca <- rda(traits.st)
#summary(traits.pca)
autoplot(traits.pca, xlab = "PCA 33.9%", ylab = "PCA 32.9%")
#PC3 is ~15%
```
### Populations
```{r}
trait.pop <- traits.ag
trait.pop$spepop <- paste(trait.pop$species, trait.pop$Site)
trait.pop <- ungroup(trait.pop) %>% select(spepop, Trait, mean)
trait.pop <- pivot_wider(trait.pop, names_from = Trait, values_from = mean)
trait.pop <- select(trait.pop, 1, 3, 5, 8, 9, 11, 13, 14)
trait.pop.st <- select(trait.pop, -1) %>% decostand(method = "standardize")
trait.pop.pca <- rda(trait.pop.st)
#summary(trait.pop.pca)
autoplot(trait.pop.pca, xlab = "PCA 35.8%", ylab = "PCA 32.2 %")
#PCA3 ~ 16%
```
## Sites
```{r}
env <- select(cov, 3:9, 12:15, 23:27, 29) %>% drop_na()
#env.labels <- select(cov, 1:2)
#options(scipen = 999)
#env.pca <- rda(env, scaling = TRUE)
#summary(env.pca)
#autoplot(env.pca)
#doesn't look good
#standardize to mean of zero etc
#not sure if correct
env.d <- decostand(env, method = "standardize")
env.pca <- rda(env.d)
summary(env.pca)
autoplot(env.pca, xlab = "PCA 31.4%", ylab = "PCA 20.3%")
```
# ITV
Intraspecific trait variation
## Body size
```{r}
itv <- data.frame()
#body size
webers <- traits %>% filter(Trait == "Webers")
partition <- aov(Measure~X.1, data = webers)
summary(partition)
#ITV is a low component of overall variability
logWebers <- log(webers$Measure)
modPart <- lme(logWebers ~ 1, random = ~ 1 | Site / X.1, data = webers, na.action = na.omit)
varcompWeber <- ape::varcomp(modPart, scale = 1)
varcompWeber
#body size differences between individuals of the same species within a site account for 9.2% variation
#differences among species within a site account for 90.7%
#differences among species between sites accounts for 0 %
```
## Femur length
```{r}
# relative leg length
femur <- traits %>% filter(Trait == "Femur.w")
partition <- aov(Measure~X.1, data = femur)
summary(partition)
#ITV is 1.208/3.298 = 36.6% of variation
logFemur <- log(femur$Measure)
modPart <- lme(logFemur ~ 1, random = ~ 1 | Site / X.1, data = femur, na.action = na.omit)
varcompFemur <- ape::varcomp(modPart, scale = 1)
varcompFemur
#relative femur length differences between individuals of the same species within a site account for 31% variation
#differences among species within a site account for 66.7%
#differences among species between sites accounts for 2.4 %
```
## Scape length
```{r}
#scape length
scape <- traits %>% filter(Trait == "Scape.w")
partition <- aov(Measure~X.1, data = scape)
summary(partition)
#ITV is 0.706/4.632 = 15.2 % of variation
logScape <- log(scape$Measure)
modPart <- lme(logScape ~ 1, random = ~ 1 | Site / X.1, data = scape, na.action = na.omit)
varcompScape <- ape::varcomp(modPart, scale = 1)
varcompScape
#relative scape length differences between individuals of the same species within a site account for 15% variation
#differences among species within a site account for 84.5%
#differences among species between sites accounts for 0%
```
## Mandible length
```{r}
#mandible length
mandible <- traits %>% filter(Trait == "Mandible.w")
partition <- aov(Measure~X.1, data = mandible)
summary(partition)
#ITV is 0.3478/0.76 = 45.7 % of variation
logMandible <- log(mandible$Measure)
modPart <- lme(logMandible ~ 1, random = ~ 1 | Site / X.1, data = mandible, na.action = na.omit)
varcompMandible <- ape::varcomp(modPart, scale = 1)
varcompMandible
#relative mandible length differences between individuals of the same species within a site account for 36.6% variation
#differences among species within a site account for 63%
#differences among species between sites accounts for 0%
```
## Eye length
```{r}
#eye length
el <- traits %>% filter(Trait == "Eyel.w")
partition <- aov(Measure~X.1, data = el)
summary(partition)
#ITV is 0.06/0.31 = 21 % of variation
logEL <- log(el$Measure)
modPart <- lme(logEL ~ 1, random = ~ 1 | Site / X.1, data = el, na.action = na.omit)
varcompEL <- ape::varcomp(modPart, scale = 1)
varcompEL
#relative eye length differences between individuals of the same species within a site account for 24% variation
#differences among species within a site account for 75.9%
#differences among species between sites accounts for 0%
```
## Head width
```{r}
#head width
hw <- traits %>% filter(Trait == "Headw.w")
partition <- aov(Measure~X.1, data = hw)
summary(partition)
#ITV is 26%
0.49/(0.49+1.39)
logHW <- log(hw$Measure)
modPart <- lme(logHW ~ 1, random = ~ 1 | Site / X.1, data = hw, na.action = na.omit)
varcompHW <- ape::varcomp(modPart, scale = 1)
varcompHW
#relative head width differences between individuals of the same species within a site account for 21.8% variation
#differences among species within a site account for 78.1%
#differences among species between sites accounts for 0%
hl <- traits %>% filter(Trait == "Headl.w")
partition <- aov(Measure~X.1, data = hl)
summary(partition)
```
# Turnover vs ITV
Community mean trait values can shift along gradients due to differences in the species composition at the sites, and also due to intraspecific variation
Compare shifts in CWM measured along a gradient using site-specific trait values to global trait values
# Alpha diversity
### more data wrangling
```{r}
library(FD)
#need a species by trait matrix, but I want to use the population means
#make species name the name + site
# need a species by site matrix with the species pop names
site.pop <- select(cov, 1, 2, 31) %>% left_join(long.pres, ., by = 'uniID')
#count uniID per site and month
counts <- site.pop %>% group_by(Site.x, month, uniID) %>% count()
counts <- counts %>% group_by(Site.x, month) %>% count()
site.pop <- site.pop %>% group_by(Site.x, month, species) %>% summarize(total = sum(count.bin))
site.pop <- left_join(site.pop, counts, by = c("Site.x", "month"))
site.pop <- mutate(site.pop, pit.abun = total/n)
site.pop <- select(site.pop, 1:3, 6)
site.pop$site.name <- paste(site.pop$Site.x, site.pop$month)
site.pop$spepop <- paste(site.pop$species, site.pop$Site.x)
site.pop <- site.pop %>% ungroup() %>% select(4:6)
wide.pop <- pivot_wider(site.pop, names_from = spepop, values_from = pit.abun)
wide.pop[is.na(wide.pop)] <- 0
sites <- wide.pop$site.name
#there are no trait measurements for species that are absent from a site
wide.pop <- ungroup(wide.pop) %>% select(-site.name)
wide.pop <- wide.pop[which(colSums(wide.pop) !=0)]
wide.pop <- cbind(sites, wide.pop)
row.names(wide.pop) <- wide.pop$sites
wide.pop <- select(wide.pop, -sites)
#can I have zero rows?
#wide.pop <- wide.pop[which(rowSums(wide.pop) !=0),]
#remove the two solenopsis singletons - no trait measuremnts
wide.pop <- select(wide.pop, -36, -42)
#check to ensure names are matched correctly between dataframes
spec <- colnames(wide.pop)
#trait.pop$spepop <- gsub(" ", "", trait.pop$spepop)
trait.pop <- as.data.frame(trait.pop)
row.names(trait.pop) <- trait.pop$spepop
trait.pop <- select(trait.pop, -spepop)
all.equal(spec, row.names(trait.pop))
```
### Null model/SES calculation
### Functional dispersion
```{r}
library(picante)
rep.is <- replicate(5, randomizeMatrix(wide.pop, null.model = "independentswap"))
numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom <- matrix(NA, nrow = nrow(wide.pop), ncol = numberReps,
dimnames = list(rownames(wide.pop),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = wide.pop, null.model = "independentswap")
simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom[, rep] <- simFDis
}
obsFDis <- dbFD(trait.pop, wide.pop, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis <- data.frame(ES3)
SES_dis$sites <- row.names(SES_dis)
#join site-level environmental measurements to data
cov$sites <- paste(cov$Site, cov$month)
SES <- select(cov, 1:15, shrub.site, sites) %>% distinct() %>% left_join(SES_dis, by = "sites")
```
## Functional dispersion
```{r}
ggplot(SES, aes(esi, ES3, color = month)) + geom_smooth(method = 'lm')
ggplot(SES, aes(Site, esi)) + geom_boxplot()
ggplot(SES, aes(arid, esi)) + geom_smooth(method = 'lm')
ggplot(SES, aes(arid, ES3)) + geom_smooth(method = 'lm')
ggplot(SES, aes(mean.cover, ES3)) + geom_smooth(method = 'lm')
ggplot(SES, aes(Max, ES3)) + geom_smooth()
ggplot(SES, aes(var.cover, ES3)) + geom_smooth()
t.test(SES$ES3)
cor.test(SES$ES3, SES$esi)
cor.test(SES$arid, SES$esi)
cor.test(SES$arid, SES$Temp)
cor.test(SES$ES3, SES$arid)
cor.test(SES$ES3, SES$Temp)
cor.test(SES$ES3, SES$Max)
cor.test(SES$ES3, SES$mean.cover)
cor.test(SES$esi, SES$mean.cover)
cor.test(SES$ES3, SES$mean.height)
cor.test(SES$ES3, SES$var.cover)
m1 <- glmmTMB(ES3 ~ arid +(1|Site), family = gaussian(), data = SES)
m2 <- glmmTMB(ES3 ~ esi+  (1|Site), family = gaussian(), data = SES)
summary(m2)
m3 <- glmmTMB(ES3 ~ mean.cover + shrub.site + (1|Site), family = gaussian(), data = SES)
AIC(m1, m2, m3)
summary(m1)
shapiro.test(resid(m1))
```
```{r}
#let's do a null model for pitfall trap level, can randomize between sites?
#for traits species should be rows, traits cols
traits.spe <- select(traits.sp, -sd)
traits.spe <- pivot_wider(traits.spe, names_from = Trait, values_from = mean)
#only keep corrected traits (divided by body length)
#only keep one head trait (keeping width)
traits.spe <- select(traits.spe, 1, 3,5,8, 9, 11, 13, 14)
traits.spe <- rename(traits.spe, species = X.1)
traits.spe <- as.data.frame(traits.spe) %>% ungroup()
traits.spe$species <- gsub(" ", "", traits.spe$species)
row.names(traits.spe) <- traits.spe$species
traits.spe <- select(traits.spe, -species)
spe.bin2 <- as.data.frame(spe.bin)
row.names(spe.bin2) <- spe.bin2$uniID
spe.bin2 <- select(spe.bin2, -uniID)
#remove zero rows
spe.bin <- spe.bin[rowSums(spe.bin) > 0,]
#remove zero rows
spe.bin2 <- spe.bin2[rowSums(spe.bin2) > 0,]
View(spe.bin2)
#let's do a null model for pitfall trap level, can randomize between sites?
#for traits species should be rows, traits cols
traits.spe <- select(traits.sp, -sd)
traits.spe <- pivot_wider(traits.spe, names_from = Trait, values_from = mean)
#only keep corrected traits (divided by body length)
#only keep one head trait (keeping width)
traits.spe <- select(traits.spe, 1, 3,5,8, 9, 11, 13, 14)
traits.spe <- rename(traits.spe, species = X.1)
traits.spe <- as.data.frame(traits.spe) %>% ungroup()
traits.spe$species <- gsub(" ", "", traits.spe$species)
row.names(traits.spe) <- traits.spe$species
traits.spe <- select(traits.spe, -species)
spe.bin <- as.data.frame(spe.bin)
row.names(spe.bin) <- spe.bin$uniID
spe.bin <- select(spe.bin, -uniID)
#remove zero rows
spe.bin <- spe.bin2[rowSums(spe.bin) > 0,]
numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom2 <- matrix(NA, nrow = nrow(spe.bin), ncol = numberReps,
dimnames = list(rownames(spe.bin),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = spe.bin, null.model = "independentswap")
simFDis <- dbFD(traits.spe, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom2[, rep] <- simFDis
}
obsFDis <- dbFD(traits.spe, spe.bin, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom2)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom2, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis_pit <- data.frame(ES3)
SES_dis_pit$sites <- row.names(SES_dis_pit)
#join site-level environmental measurements to data
mean(SES_dis_pit$ES3)
SES_dis_pit$uniID <- SES_dis_pit$sites
SES_pit <- left_join(SES_dis_pit, cov, by = "uniID")
ggplot(SES_pit, aes(Microsite, ES3)) + geom_boxplot()
ggplot(SES_pit, aes(esi, ES3, color = Microsite)) + geom_smooth(method = "lm")
ggplot(SES_pit, aes(esi, ES3, color = shrub.site)) + geom_smooth(method = "lm")
m1 <- glmmTMB(ES3 ~ esi + Microsite+ arid + dry.veg.percent  +  shrub.site+ mean.cover + (1|Site) + (1|month), family = "gaussian", data = SES_pit)
summary(m1)
shapiro.test(resid(m1))
plot(resid(m1))
m2 <- glmmTMB(Species ~ esi + Microsite+ arid + dry.veg.percent  +  shrub.site+ mean.cover + (1|Site) + (1|month), family = "poisson", data = SES_pit)
summary(m2)
#let's do a null model for pitfall trap level, can randomize between sites?
#for traits species should be rows, traits cols
traits.spe <- select(traits.sp, -sd)
traits.spe <- pivot_wider(traits.spe, names_from = Trait, values_from = mean)
#only keep corrected traits (divided by body length)
#only keep one head trait (keeping width)
traits.spe <- select(traits.spe, 1, 3,5,8, 9, 11, 13, 14)
traits.spe <- rename(traits.spe, species = X.1)
traits.spe <- as.data.frame(traits.spe) %>% ungroup()
traits.spe$species <- gsub(" ", "", traits.spe$species)
row.names(traits.spe) <- traits.spe$species
traits.spe <- select(traits.spe, -species)
spe.bin <- as.data.frame(spe.bin)
row.names(spe.bin) <- spe.bin$uniID
spe.bin <- select(spe.bin, -uniID)
#remove zero rows
spe.bin <- spe.bin[rowSums(spe.bin) > 0,]
numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom2 <- matrix(NA, nrow = nrow(spe.bin), ncol = numberReps,
dimnames = list(rownames(spe.bin),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = spe.bin, null.model = "independentswap")
simFDis <- dbFD(traits.spe, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom2[, rep] <- simFDis
}
obsFDis <- dbFD(traits.spe, spe.bin, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom2)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom2, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis_pit <- data.frame(ES3)
SES_dis_pit$sites <- row.names(SES_dis_pit)
#join site-level environmental measurements to data
mean(SES_dis_pit$ES3)
SES_dis_pit$uniID <- SES_dis_pit$sites
SES_pit <- left_join(SES_dis_pit, cov, by = "uniID")
ggplot(SES_pit, aes(Microsite, ES3)) + geom_boxplot()
ggplot(SES_pit, aes(esi, ES3, color = Microsite)) + geom_smooth(method = "lm")
ggplot(SES_pit, aes(esi, ES3, color = shrub.site)) + geom_smooth(method = "lm")
m1 <- glmmTMB(ES3 ~ esi + Microsite+ arid + dry.veg.percent  +  shrub.site+ mean.cover + (1|Site) + (1|month), family = "gaussian", data = SES_pit)
summary(m1)
shapiro.test(resid(m1))
plot(resid(m1))
m2 <- glmmTMB(Species ~ esi + Microsite+ arid + dry.veg.percent  +  shrub.site+ mean.cover + (1|Site) + (1|month), family = "poisson", data = SES_pit)
summary(m2)
m1 <- glmmTMB(ES3 ~ esi + Microsite+ arid + dry.veg.percent  +  shrub.site+ mean.cover + (1|Site) + (1|month), family = "gaussian", data = SES_pit)
View(SES_pit)
numberReps <- 100
#Lets create a matrix to store results from each iteration (one column per iteration)
resultsRandom2 <- matrix(NA, nrow = nrow(spe.bin), ncol = numberReps,
dimnames = list(rownames(spe.bin),
paste0("Sim.", 1:numberReps)))
for(rep in 1:numberReps){
randomizedFDis <- randomizeMatrix(samp = spe.bin, null.model = "independentswap")
simFDis <- dbFD(traits.spe, randomizedFDis, w.abun = TRUE)$FDis
resultsRandom2[, rep] <- simFDis
}
View(traits.spe)
View(spe.bin2)
View(spe.bin)
