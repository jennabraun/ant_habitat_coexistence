ggplot(filter(CWM, Trait == "Eyel.w"), aes(Site, cwm)) + geom_boxplot() + ylab("CWM Eye length")
ggplot(filter(CWM, Trait == "Femur.w"), aes(Site, cwm)) + geom_boxplot() + ylab("CWM Femur")
ggplot(filter(CWM, Trait == "Scape.w"), aes(Site, cwm)) + geom_boxplot() + ylab("CWM Scape")
ggplot(filter(CWM, Trait == "Headw.w"), aes(Site, cwm)) + geom_boxplot() + ylab("CWM Head width")
ggplot(filter(CWM, Trait == "Webers"), aes(Site, cwm)) + geom_boxplot() + ylab("CWM Webers body length")
#dividing by body length increased the variability in traits between sites, before just looks like body length
mat <- pivot_wider(CWM, names_from = Trait, values_from = cwm)
mat <- select(mat, 5:11, 14:17, 25:31, 36:48) %>% ungroup()
mat <- ungroup(mat) %>% select(-uniID)
mat <- drop_na(mat)
#str(mat)
M <- cor(mat)
corrplot::corrplot(M, method = "number")
# I want the PCA on traits
# make it wide again
traits.wide <- pivot_wider(traits, names_from = Trait, values_from = Measure)
traits.wide <- select(traits.wide, 11:17)
traits.wide <- drop_na(traits.wide)
library(vegan)
library(ggvegan)
traits.pca <- rda(traits.wide)
#summary(traits.pca)
#no scaling because the traits all have the same units
autoplot(traits.pca, xlab = "PCA 82.8%", ylab = "PCA 10.5%")
library(vegan)
env <- select(cov, 3:9, 12:15, 23:27, 29) %>% drop_na()
env.labels <- select(cov, 1:2)
options(scipen = 999)
env.pca <- rda(env, scaling = TRUE)
#summary(env.pca)
autoplot(env.pca)
#doesn't look good
#standardize to mean of zero etc
#not sure if correct
env.d <- decostand(env, method = "standardize")
env.pca <- rda(env.d)
#summary(env.pca)
autoplot(env.pca, xlab = "PCA 31.4%", ylab = "PCA 20.3%")
library(betapart)
spe.bin.core <- betapart.core(spe.bin)
#We need to set up our data
spe <- wide
#for traits species should be rows, traits cols
traits.spe <- select(traits.sp, -sd)
traits.spe <- pivot_wider(traits.spe, names_from = Trait, values_from = mean)
#only keep corrected traits (divided by body length)
#only keep one head trait (keeping width)
traits.spe <- select(traits.spe, 1, 3,5, 9, 11, 13, 14)
traits.spe <- rename(traits.spe, species = X.1)
row.names(traits.spe) <- traits.spe$species
traits.spe <- as.data.frame(traits.spe) %>% ungroup()
traits.spe <- select(traits.spe, -species)
#I want veg height but there are NAs ugh
env4 <- select(cov, uniID, 3, 4, 5,12, 13, 17, 23, 29, 34)
env4$Microsite <- as.factor(env4$Microsite)
naveg <- env4[is.na(env4$veg..height),]
#make a vector of NA values
naveg <- naveg$uniID
`%!in%` <- Negate(`%in%`)
#remove those NA rows from the species table
spe <- spe[spe$uniID %!in% naveg, ]
env4 <- env4[env4$uniID %!in% naveg, ]
row.names(env4) <- env4$uniID
env4 <- env4[,-1]
row.names(spe) <- spe$uniID
spe <- select(spe, -1, -2)
spe.bin <- spe
spe.bin[spe.bin > 1] <- 1
spe.bin.core <- betapart.core(spe.bin)
spe.bin.multi <- beta.multi(spe.bin)
spe.bin.samp <- beta.sample(spe.bin.core, sites = 9, samples = 100)
dist.s <- spe.bin.samp$sampled.values
plot(density(dist.s$beta.SOR), xlim=c(0,0.8), ylim=c(0, 19), xlab="Beta diversity", main="", lwd=3)
lines(density(dist.s$beta.SNE), lty=1, lwd=2)
lines(density(dist.s$beta.SIM), lty=2, lwd=2)
dist <- beta.pair(spe.bin, index.family = "sorensen")
bd <- vegan::betadisper(dist[[3]], env4$shrub.site)
anova(bd)
TukeyHSD(bd)
adonis(dist[[3]] ~ env4$shrub.site, perm=999)
View(env4)
install.packages("FD")
library(FD)
gow <- gowdis(env4)
mant <- mantel(gow, dist)
gow <- as.matrix(gow)
mant <- mantel(gow, dist)
mant <- mantel(gow, dist[[3]])
gow <- gowdis(env4)
mant <- mantel(gow, dist[[3]])
gow <- as.matrix(gow)
View(gow)
sor <- dist[[3]]
sor <- as.matrix(sor)
mant <- mantel(gow, sor)
mant <- mantel(gow, sor, method = "spearman", permutations = 999, na.rm = TRUE)
mant
euc <- dist(env4, "euclidean")
mant <- mantel(euc, sor, method = "spearman", permutations = 999, na.rm = TRUE)
mant
euc.dry <-dist(env4$dry.veg.percent, "euclidean")
mantel(euc.dry, sor, method = "spearman", permutations = 999, na.rm = TRUE)
euc.Prec <- dist(env$Prec, "euclidean")
mantel(euc.Prec, sor, method = "spearman", permutations = 99, na.rm = TRUE)
euc.esi <- dist(env$esi, "euclidean")
mantel(euc.esi, sor, method = "spearman", permutations = 99, na.rm = TRUE)
euc.vegheight <- dist(env$veg..height, "euclidean")
mantel(euc.vegheight, sor, method = "spearman", permutations = 99, na.rm = TRUE)
euc.temp <- dist(env$Temp, "euclidean")
mantel(euc.Temp, sor, method = "spearman", permutations = 99, na.rm = TRUE)
mantel(euc.temp, sor, method = "spearman", permutations = 99, na.rm = TRUE)
euc.siteveg <- dist(env$mean.bare, "euclidean")
mantel(euc.siteveg, sor, method = "spearman", permutations = 99, na.rm = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(performance)
library(glmmTMB)
library(ade4)
library(nlme)
library(ape)
library(betapart)
library(vegan)
plot(euc.dry, sor)
plot(euc.dry, sor, na.rm = TRUE)
euc.dry <-dist(env4$dry.veg.percent, "euclidean")
mantel(euc.dry, sor, method = "spearman", permutations = 999, na.rm = TRUE)
mant
library(dplyr)
library(tidyr)
library(ggplot2)
library(performance)
library(glmmTMB)
library(ade4)
library(nlme)
library(ape)
View(wide)
pitlabels <- select(wide, 1 ,2)
pitwide <- wide
pitwide <- select(pitwide, -1, -2)
View(pitwide)
#calculate pairwise C-Scores
pitc <- designdist(t(pitwide), "(A-J)*(B-J)", "binary")
library(vegan)
#calculate pairwise C-Scores
pitc <- designdist(t(pitwide), "(A-J)*(B-J)", "binary")
pitc <- as.matrix(pitc)
View(pitc)
View(pitwide)
#make dataframe presence/absence
pitwide[pitwide > 1] <- 1
View(pitwide)
#calculate pairwise C-Scores
pitc <- designdist(t(pitwide), "(A-J)*(B-J)", "binary")
pitc <- as.matrix(pitc)
View(pitc)
View(pitwide)
#calculate pairwise C-Scores
pitc <- designdist(t(pitwide), "(A-J)*(B-J)", "binary")
pitc <- as.matrix(pitc)
#calculate pairwise C-Scores
pitc <- designdist(pitwide, "(A-J)*(B-J)", "binary")
pitc <- as.matrix(pitc)
View(pitc)
#let's try with a package
library(ecospat)
install.packages("ecospat")
install.packages("ecospat")
library(bipartite)
c <- C.score(pitwide, normalise = TRUE, FUN = hist)
C.score(pitwide, normalise = TRUE, FUN = mean)
?C.score
View(dist)
View(pitc)
#calculate pairwise C-Scores
pitc <- designdist(t(pitwide), "(A-J)*(B-J)", "binary")
pitc <- as.matrix(pitc)
View(pitc)
C.score(pitwide, normalise = TRUE, FUN = print)
install.packages("ecosimR")
install.packages("EcoSimR")
install.packages("enmeval")
install.packages("ENMeval")
install.packages("dismo")
#ant SDMs
#tutorial from vignette
# Load packages -- the order here is important because some pkg functions overwrite others.
library(ENMeval)
library(raster)
library(dplyr)
# Set a random seed in order to be able to reproduce this analysis.
set.seed(48)
# You can search online databases like GBIF using the spocc package (commented below),
# but here we will load in some pre-downloaded data.
# bv <- spocc::occ('Bradypus variegatus', 'gbif', limit=300, has_coords=TRUE)
# occs <- as.data.frame(bv$gbif$data$Bradypus_variegatus[,2:3])
occs <- readRDS("bvariegatus.rds")
envs.files <- list.files(path=paste(system.file(package='dismo'), '/ex', sep=''),
pattern='grd', full.names=TRUE)
# Read the raster files into a RasterStack.
# These variables represent 8 bioclimatic variables and one categorical variable "biome".
# Find the descriptions of the bioclimatic variables here:
# https://www.worldclim.org/data/bioclim.html
envs <- raster::stack(envs.files)
# The biome raster has some NAs for cells that have values in the other rasters.
# Let's mask all rasters to biome to change the value of these cells to NA for all rasters.
# ENMeval will do this automatically, but let's do it here to avoid the warning message later.
# We change back from a RasterBrick to RasterStack because of issues with assigning
# factor rasters for RasterBricks.
envs <- raster::mask(envs, envs[[9]]) %>% raster::stack()
# Make sure to declare the categorical variable as a factor
envs$biome <- raster::as.factor(envs$biome)
# Let's now remove occurrences that are cell duplicates -- these are
# occurrences that share a grid cell in the predictor variable rasters.
# Although Maxent does this by default, keep in mind that for other algorithms you may
# or may not want to do this based on the aims of your study.
# Another way to space occurrence records a defined distance from each other to avoid
# spatial autocorrelation is with spatial thinning (Aiello-Lammens et al. 2015).
occs.cells <- raster::extract(envs[[1]], occs, cellnumbers = TRUE)
occs.cellDups <- duplicated(occs.cells[,1])
occs <- occs[!occs.cellDups,]
# Plot first raster in the stack, the mean annual temperature.
plot(envs[[1]], main="Mean annual temperature")
#read in GABI ants data
ants <- read.csv("raw data/GABI_Data_Release1.0_18012020.csv")
View(ants)
fire <- filter(ants, valid_species_name = "solenopsis.xyloni")
fire <- filter(ants, valid_species_name == "solenopsis.xyloni")
fire <- filter(ants, valid_species_name == "Solenopsis.xyloni")
View(fire)
fire <- filter(fire, dubious != "dubious")
fire <- filter(fire, dubious != "Dubious")
count(fire$country)
unique(fire$country)
#I'm removing the Bahamas population
fire <- filter(fire, country != "Bahamas")
unique(fire$country)
fire <- filter(fire, dec_lat != "")
library(sf)
?sf
crs <- envs@crs
View(crs)
fire_sf <- st_as_sf(fire, coords = c("dec_long", "dec_lat"), crs)
fire_sf <- st_sfc(fire, coords = c("dec_long", "dec_lat"), crs)
crs@projargs
fire_sf <- st_sfc(fire, coords = c("dec_long", "dec_lat"), EPSG:4326)
fire_sf <- st_sfc(fire, coords = c("dec_long", "dec_lat"), 4326)
fire_sf <- st_read(fire, options=c("dec_long=x","dec_lat=y"))
crs <- st_crs(envs)
View(crs)
fire_sf <- st_as_sf(fire, coords = c("dec_long", "dec_lat"), crs= crs)
plot(fire_sf)
occs.cells <- raster::extract(envs[[1]], fire_sf, cellnumbers = TRUE)
occs.cellDups <- duplicated(occs.cells[,1])
occs <- occs[!occs.cellDups,]
occs <- fire_sf
plot(envs[[1]], main="Mean annual temperature")
points(occs)
?sf
plot(occs, add = TRUE)
sh <- st_read("raw data/Bentity2_shapefile_fullres.shp")
plot(sh, add = TRUE)
st_crs(sh)
st_crs(envs)
?sf
st_crs(fire_Sf)
st_crs(fire_sf)
fire_sf <- st_as_sf(fire, coords = c("dec_long", "dec_lat"), crs= st_crs(sh))
st_crs(fire_sf)
occs <- fire_sf
occs <- occs[!occs.cellDups,]
plot(envs[[1]], main="Mean annual temperature")
plot(occs, add = TRUE)
occs <- st_transform(occs, crs = st_crs(envs))
plot(envs[[1]], main="Mean annual temperature")
plot(occs, add = TRUE)
View(occs)
?st_transform
occs <- fire_sf
occs <- st_transform(occs, crs = st_crs(envs), type = "datums")
plot(envs[[1]], main="Mean annual temperature")
plot(occs, add = TRUE)
plot(envs[[1]], main="Mean annual temperature")
plot(occs, add = TRUE)
st_crs(occs)
st_crs(envs)
?st_transform
occs <- fire_sf
occs <- occs[!occs.cellDups,]
occs <- st_transform(occs, crs = st_crs(envs), type = "ellps")
plot(envs[[1]], main="Mean annual temperature")
plot(occs, add = TRUE)
plot(envs[[1]], main="Mean annual temperature")
plot(occs, add = TRUE)
occs <- fire_sf
occs <- occs[!occs.cellDups,]
occs <- st_transform(occs, crs = st_crs(envs))
plot(envs[[1]], main="Mean annual temperature")
plot(occs, add = TRUE)
occs <- st_transform(occs, crs = st_crs(envs), type = "ellps")
plot(envs[[1]], main="Mean annual temperature")
plot(occs, add = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(performance)
library(glmmTMB)
library(ade4)
library(nlme)
library(ape)
library(vegan)
wide <- read.csv("Clean Data/ants_wide.csv")
cov <- read.csv("Clean Data/ants.csv")
sites <- read.csv("Clean Data/sites_joined.csv")
cov <- right_join(sites, cov, by = c("Site", "month"))
cov <- dplyr::select(cov, 3:10, 14:19, 22:36, 39:41)
#add ecostress sensor data
eco <- read.csv("Clean Data/ecostress.csv")
eco <- select(eco, 1, 2, 11)
eco <- rename(eco, month = Category, Site = ID, esi = ECO4ESIPTJPL_001_Evaporative_Stress_Index_PT_JPL_ESIavg)
cov <- right_join(eco, cov, by = c("Site", "month"))
shrubs <- read.csv("Clean Data/shrubs.csv")
cov <- right_join(cov, shrubs, by = "Site")
cov$shrub.site <- as.factor(cov$shrub.site)
traits <- read.csv("raw data/Traits.csv")
unique(traits$Trait)
#I don't trust the eye width measurements because they were from the front
traits <- filter(traits, Trait != "Eye width")
traits <- separate(traits, Photo, c("Site", "Slide", "Specimen"))
traits$Site <- gsub("Papl", "PaPl", traits$Site)
unique(traits$Site)
traits <- traits[-1,]
#remove the double pheidole entry
traits <- traits[-2,]
#need to divide the trait values by weber's body length. I want to do this at the individual level
traits <- select(traits, -X, -Label)
traits <- pivot_wider(traits, names_from = Trait, values_from = Measure)
traits <- mutate(traits, Femur.w = Femur/Webers, Scape.w = Scape/Webers, Mandible.w = `Mandible length`/Webers, Headl.w = `Head width`/Webers, Eyel.w = `Eye length`/Webers, Headw.w = `Head width`/Webers)
traits <- pivot_longer(traits, 5:17, names_to = "Trait", values_to = "Measure")
unique(traits$X.1)
#some traits are NA because of damage to the specimen
traits <- drop_na(traits)
#calculate the mean value of the trait for each species at each site
traits.ag <- group_by(traits, Site, X.1, Trait) %>%
summarise(mean = mean(Measure), sd = sd(Measure))
#create a data frame of the mean values for each species across all sites
traits.sp <- group_by(traits, X.1, Trait) %>%
summarise(mean = mean(Measure), sd = sd(Measure))
#calculate CWM trait values
#I want to do abundance
#it's proportional abundances
site.j <- select(cov, uniID, Site)
wide <- right_join(site.j, wide, by = "uniID")
wide <- select(wide, -X)
#remove the two other solenopsis species with 1 individual
wide <- select(wide, -12, -13)
#wide <- rename(wide, Site = Site.x) %>%
#select(-Site.y)
long <- pivot_longer(wide, 3:13, names_to = "species", values_to = "count")
#get total abundance per trap
long <- group_by(long, uniID) %>%
mutate(total = sum(count))
long <- long %>% mutate(rel.abun = count/total)
traits.ag <- rename(traits.ag, species = X.1)
traits.ag$species <- gsub(" ", "", traits.ag$species)
#this adds NA traits to 0 abundances - species isn't found at pitfall or site
join.right <- right_join(traits.ag, long, by = c("Site", "species"))
#join.left <- left_join(traits.ag, long, by = c("Site", "species"))
CWM <- mutate(join.right, cwm.prod = mean*rel.abun)
CWM <- group_by(CWM, Site, uniID, Trait) %>% summarise(cwm = sum(cwm.prod))
#can log transform the abundances to look at dominants vs subordinates
#join environmental data to CWM trait dataframe
CWM <- left_join(CWM, cov, by = "uniID")
long.pres <- pivot_longer(wide, 3:13, names_to = "species", values_to = "count")
long.pres <- mutate(long.pres, count.bin = ifelse(count >= 1, 1, 0))
#get total abundance per trap
long.pres <- group_by(long.pres, uniID) %>%
mutate(total = sum(count.bin))
long.pres <- long.pres %>% mutate(rel.abun = count.bin/total)
#traits.ag <- rename(traits.ag, species = X.1)
#traits.ag$species <- gsub(" ", "", traits.ag$species)
#this adds NA traits to 0 abundances - species isn't found at pitfall or site
join.right <- right_join(traits.ag, long.pres, by = c("Site", "species"))
#join.left <- left_join(traits.ag, long, by = c("Site", "species"))
CWM.pres <- mutate(join.right, cwm.prod = mean*rel.abun)
CWM.pres <- group_by(CWM.pres, Site, uniID, Trait) %>% summarise(cwm = sum(cwm.prod))
#can log transform the abundances to look at dominants vs subordinates
#join environmental data to CWM trait dataframe
CWM.pres <- left_join(CWM.pres, cov, by = "uniID")
#We need to set up our data
spe <- wide
#for traits species should be rows, traits cols
traits.spe <- select(traits.sp, -sd)
traits.spe <- pivot_wider(traits.spe, names_from = Trait, values_from = mean)
#only keep corrected traits (divided by body length)
#only keep one head trait (keeping width)
traits.spe <- select(traits.spe, 1, 3,5, 9, 11, 13, 14)
traits.spe <- rename(traits.spe, species = X.1)
row.names(traits.spe) <- traits.spe$species
traits.spe <- as.data.frame(traits.spe) %>% ungroup()
traits.spe <- select(traits.spe, -species)
#I want veg height but there are NAs ugh
env4 <- select(cov, uniID, 3, 4, 5,12, 13,15,  17, 23, 29, 34)
env4$Microsite <- as.factor(env4$Microsite)
naveg <- env4[is.na(env4$veg..height),]
#make a vector of NA values
naveg <- naveg$uniID
`%!in%` <- Negate(`%in%`)
#remove those NA rows from the species table
spe <- spe[spe$uniID %!in% naveg, ]
env4 <- env4[env4$uniID %!in% naveg, ]
row.names(env4) <- env4$uniID
env4 <- env4[,-1]
row.names(spe) <- spe$uniID
spe <- select(spe, -1, -2)
spe.bin <- spe
spe.bin[spe.bin > 1] <- 1
library(betapart)
spe.bin.core <- betapart.core(spe.bin)
spe.bin.multi <- beta.multi(spe.bin)
spe.bin.samp <- beta.sample(spe.bin.core, sites = 9, samples = 100)
dist <- beta.pair(spe.bin, index.family = "sorensen")
bd <- vegan::betadisper(dist[[3]], env4$shrub.site)
boxplot(bd)
anova(bd)
# difference in dispersion between the three
TukeyHSD(bd)
# contrasts not significant. ok.
library(FD)
library(vegan)
gow <- gowdis(env4)
euc <- dist(env4, "euclidean")
gow <- as.matrix(gow)
sor <- dist[[3]]
sor <- as.matrix(sor)
sor.mean <- rowMeans(sor, na.rm = TRUE)
sim <- as.matrix(dist[[1]])
sim.mean <- rowMeans(sim, na.rm = TRUE)
sne <- as.matrix(dist[[2]])
sne.mean <- rowMeans(sne, na.rm = TRUE)
envbeta <- cbind(env4, sor.mean, sim.mean, sne.mean)
envlong <- pivot_longer(envbeta, 11:13, names_to = "beta", values_to = "mean")
envlong <- pivot_longer(envlong, c(1:6, 8, 9), names_to = "env", values_to = "value")
ggplot(envlong, aes(value,mean , color = beta)) +
stat_smooth(method = "lm") + facet_wrap(~env, scales = "free")
euc.dry <-dist(env4$dry.veg.percent, "euclidean")
euc.Prec <- dist(env4$Prec, "euclidean")
euc.esi <- dist(env4$esi, "euclidean")
euc.vegheight <- dist(env4$veg..height, "euclidean")
euc.temp <- dist(env4$Temp, "euclidean")
euc.siteveg <- dist(env4$mean.bare, "euclidean")
euc.arid <- dist(env4$arid, "euclidean")
mantel(euc.dry, sor, method = "spearman", permutations = 999, na.rm = TRUE)
mantel(euc.Prec, sor, method = "spearman", permutations = 99, na.rm = TRUE)
mantel(euc.esi, sor, method = "spearman", permutations = 99, na.rm = TRUE)
mantel(euc.vegheight, sor, method = "spearman", permutations = 99, na.rm = TRUE)
mantel(euc.temp, sor, method = "spearman", permutations = 99, na.rm = TRUE)
mantel(euc.siteveg, sor, method = "spearman", permutations = 99, na.rm = TRUE)
# dry.veg. percent matters
# site level differences do
#yes, beta diversity (species composition) is correlated with the environment
euc.arid <- dist(env4$arid, "euclidean")
mantel(euc.arid, sor, method = "spearman", permutations = 99, na.rm = TRUE)
mantel(euc.siteveg, sor, method = "spearman", permutations = 99, na.rm = TRUE)
euc.dry <-dist(env4$dry.veg.percent, "euclidean")
euc.Prec <- dist(env4$Prec, "euclidean")
euc.esi <- dist(env4$esi, "euclidean")
euc.vegheight <- dist(env4$veg..height, "euclidean")
euc.temp <- dist(env4$Temp, "euclidean")
euc.siteveg <- dist(env4$mean.bare, "euclidean")
mantel(euc.esi, sor, method = "spearman", permutations = 99, na.rm = TRUE)
mantel(euc.vegheight, sor, method = "spearman", permutations = 99, na.rm = TRUE)
mantel(euc.temp, sor, method = "spearman", permutations = 99, na.rm = TRUE)
View(envbeta)
View(env4)
View(cov)
env4 <- select(cov, uniID, 2, 3, 4, 5,12, 13,15,  17, 23, 29, 34)
env4$Microsite <- as.factor(env4$Microsite)
naveg <- env4[is.na(env4$veg..height),]
#make a vector of NA values
naveg <- naveg$uniID
`%!in%` <- Negate(`%in%`)
env4 <- env4[env4$uniID %!in% naveg, ]
row.names(env4) <- env4$uniID
View(env4)
env4 <- env4[,-1]
gow <- gowdis(env4)
euc <- dist(env4, "euclidean")
gow <- as.matrix(gow)
sor <- dist[[3]]
sor <- as.matrix(sor)
sor.mean <- rowMeans(sor, na.rm = TRUE)
sim <- as.matrix(dist[[1]])
sim.mean <- rowMeans(sim, na.rm = TRUE)
sne <- as.matrix(dist[[2]])
sne.mean <- rowMeans(sne, na.rm = TRUE)
envbeta <- cbind(env4, sor.mean, sim.mean, sne.mean)
mb <- glmmTMB(sor.mean ~  dry.veg.percent + Microsite  + mean.cover +  esi + mean.height +  shrub.site + arid + month + veg..height + (1|Site), data = envbeta)
mb <- glmmTMB(sor.mean ~  dry.veg.percent + Microsite  + mean.cover +  esi +   shrub.site + arid + month + veg..height + (1|Site), data = envbeta)
mb <- glmmTMB(sor.mean ~  dry.veg.percent + Microsite  + mean.cover +  esi +   shrub.site + arid  + veg..height + (1|Site), data = envbeta)
summary(mb)
mb <- glmmTMB(sim.mean ~  dry.veg.percent + Microsite  + mean.cover +  esi +   shrub.site + arid  + veg..height + (1|Site), data = envbeta)
summary(mb)
mb <- glmmTMB(sne.mean ~  dry.veg.percent + Microsite  + mean.cover +  esi +   shrub.site + arid  + veg..height + (1|Site), data = envbeta)
summary(mb)
?betapart
?betapart.core
mb <- glmmTMB(sim.mean ~  dry.veg.percent + Microsite  + mean.cover +  esi +   shrub.site + arid  + veg..height + (1|Site), data = envbeta)
summary(mb)
mb <- glmmTMB(sim.mean ~  dry.veg.percent + Microsite  + mean.cover +  esi  + arid  + veg..height + (1|Site), data = envbeta)
summary(mb)
?decay.model
