join.right <- right_join(traits.ag, long.pres, by = c("Site", "species"))
CWM.pres <- mutate(join.right, cwm.prod = mean*rel.abun)
CWM.pres <- group_by(CWM.pres, Site, uniID, Trait) %>% summarise(cwm = sum(cwm.prod))
#join environmental data to CWM trait dataframe
CWM.pres <- left_join(CWM.pres, cov, by = "uniID")
traits.sp <- traits.sp %>%
select(.,-sd) %>%
pivot_wider(names_from = Trait, values_from = mean) %>%
as.data.frame(traits.sp)
traits.sp <- select(traits.sp, 1, 3, 5, 8, 9, 11, 13, 14)
traits.sp$X.1 <- gsub(" ", ".", traits.sp$X.1)
species.name <- traits.sp$X.1
#gower dissimilarity?
gow <- gowdis(traits.sp)
gow <- as.matrix(gow)
row.names(gow) <- species.name
euc <- dist(traits.sp, "euclidean")
size <- dist(traits.sp$Femur.w, "euclidean")
over2 <- as.matrix(over2[order(row.names(over2)),])
over2 <- over2[,order(colnames(over2))]
View(overdis)
over2 <- as.matrix(over2[order(row.names(over2)),])
over2 <- over2[,order(colnames(over2))]
overdis <- 1 - over2
mantel(gow, overdis)
View(overdis)
saveRDS(two, file = "Clean Data/objects/predictionrasters.rds")
saveRDS(overdis, file = "Clean Data/objects/overlap_dissim.rds")
mantel(gow, overdis)
library(ENMeval)
library(raster)
library(dplyr)
library(sf)
library(vegan)
mantel(gow, overdis)
View(overdis)
library(dplyr)
library(tidyr)
library(ggplot2)
library(performance)
library(glmmTMB)
library(vegan)
library(ggvegan)
library(FD)
library(picante)
library(purrr)
library(gridExtra)
multiple.func <- function(x) {
c(mean = mean(x), sd = sd(x))
}
#see Cleaning.R in scripts folder for data cleaning
wide <- read.csv("Clean Data/ants_wide.csv")
cov <- read.csv("Clean Data/ants.csv")
site_data <- read.csv("Clean Data/sites_joined.csv")
cov <- right_join(site_data, cov, by = c("Site", "month"))
cov <- dplyr::select(cov, 3:10, 14:19, 22:36, 39:41)
#total count of ants
sum(cov$abun)
#add ecostress sensor data
eco <- read.csv("Clean Data/ecostress.csv")
eco <- select(eco, 1, 2, 11)
eco <- rename(eco, month = Category, Site = ID, esi = ECO4ESIPTJPL_001_Evaporative_Stress_Index_PT_JPL_ESIavg)
cov <- right_join(eco, cov, by = c("Site", "month"))
#read in foundation plant identity for the sites
shrubs <- read.csv("Clean Data/shrubs.csv")
cov <- right_join(cov, shrubs, by = "Site")
cov$shrub.site <- as.factor(cov$shrub.site)
#read in ndvi and soil data
ndvi <- read.csv("raw data/sites_remotesensing.csv")
ndvi <- select(ndvi, 7:17) %>%
rename(Site = site)
ndvi$Site <- gsub("MoV", "Mov", ndvi$Site)
cov <- right_join(cov, ndvi, by = c("Site", "month"))
cov$sites <- paste(cov$Site, cov$month)
#cleaning the raw trait data
traits <- read.csv("raw data/Traits.csv")
#check for spelling mistakes in trait labels
unique(traits$Trait)
#I don't trust the eye width measurements because they were measured from the front
traits <- filter(traits, Trait != "Eye width")
#unique(traits$Photo)
#extract site IDs from photo names
traits <- separate(traits, Photo, c("Site", "Slide", "Specimen"))
traits$Site <- gsub("Papl", "PaPl", traits$Site)
unique(traits$Site)
traits <- traits[-1,]
#remove the double pheidole entry
traits <- traits[-2,]
#need to divide the trait values by weber's body length. I want to do this at the individual level, not dividing means by mean webers
traits <- select(traits, -X, -Label)
traits <- pivot_wider(traits, names_from = Trait, values_from = Measure)
traits <- mutate(traits, Femur.w = Femur/Webers, Scape.w = Scape/Webers, Mandible.w = `Mandible length`/Webers, Headl.w = `Head length`/Webers, Eyel.w = `Eye length`/Webers, Headw.w = `Head width`/Webers)
traits <- pivot_longer(traits, 5:17, names_to = "Trait", values_to = "Measure")
#check for ant species name typoes
unique(traits$X.1)
#some traits are NA because of damage to the specimen
traits <- drop_na(traits)
#calculate the mean value of the trait for each species at each site (population level trait values)
traits.ag <- group_by(traits, Site, X.1, Trait) %>%
summarise(mean = mean(Measure), sd = sd(Measure))
#create a data frame of the mean values for each species across all sites (species level trait values)
traits.sp <- group_by(traits, X.1, Trait) %>%
summarise(mean = mean(Measure), sd = sd(Measure))
#we could also try to log transform the abundances to reduce the impact of colony size
#this is presence absence
long.pres <- pivot_longer(wide, 2:14, names_to = "species", values_to = "count")
long.pres <- mutate(long.pres, count.bin = ifelse(count >= 1, 1, 0))
spe.bin <- long.pres
#get total abundance per trap
long.pres <- group_by(long.pres, uniID) %>%
mutate(total = sum(count.bin))
#calculate relative abundances
long.pres <- long.pres %>% mutate(rel.abun = count.bin/total)
traits.ag <- rename(traits.ag, species = X.1)
traits.ag$species <- gsub(" ", "", traits.ag$species)
#add sites to long
long.pres <- cov %>% select(Site, uniID) %>% right_join(long.pres, . , by = 'uniID')
#this adds NA traits to 0 abundances - species isn't found at pitfall or site
join.right <- right_join(traits.ag, long.pres, by = c("Site", "species"))
CWM.pres <- mutate(join.right, cwm.prod = mean*rel.abun)
CWM.pres <- group_by(CWM.pres, Site, uniID, Trait) %>% summarise(cwm = sum(cwm.prod))
#join environmental data to CWM trait dataframe
CWM.pres <- left_join(CWM.pres, cov, by = "uniID")
#make a presence/absence pitfall trap data frame
spe.bin <- select(spe.bin, 2, 3, 5)
spe.bin <- pivot_wider(spe.bin, names_from = species, values_from = count.bin)
spe.bin <- select(spe.bin, -11, -12)
mat <- pivot_wider(CWM.pres, names_from = Trait, values_from = cwm)
mat <- select(mat, 5:11, 14:17, 25:29, 31, 38:44, 46, 48, 51, 52, 54, 55, 57) %>% ungroup()
mat <- ungroup(mat) %>% select(-uniID)
mat <- drop_na(mat)
#str(mat)
M <- cor(mat)
corrplot::corrplot(M, method = "number")
# Chunk 1: setup
library(dplyr)
library(tidyr)
library(ggplot2)
library(performance)
library(glmmTMB)
library(vegan)
library(ggvegan)
library(FD)
library(picante)
library(purrr)
library(gridExtra)
# Chunk 2
multiple.func <- function(x) {
c(mean = mean(x), sd = sd(x))
}
# Chunk 3
#see Cleaning.R in scripts folder for data cleaning
wide <- read.csv("Clean Data/ants_wide.csv")
cov <- read.csv("Clean Data/ants.csv")
site_data <- read.csv("Clean Data/sites_joined.csv")
cov <- right_join(site_data, cov, by = c("Site", "month"))
cov <- dplyr::select(cov, 3:10, 14:19, 22:36, 39:41)
#total count of ants
sum(cov$abun)
#add ecostress sensor data
eco <- read.csv("Clean Data/ecostress.csv")
eco <- select(eco, 1, 2, 11)
eco <- rename(eco, month = Category, Site = ID, esi = ECO4ESIPTJPL_001_Evaporative_Stress_Index_PT_JPL_ESIavg)
cov <- right_join(eco, cov, by = c("Site", "month"))
#read in foundation plant identity for the sites
shrubs <- read.csv("Clean Data/shrubs.csv")
cov <- right_join(cov, shrubs, by = "Site")
cov$shrub.site <- as.factor(cov$shrub.site)
#read in ndvi and soil data
ndvi <- read.csv("raw data/sites_remotesensing.csv")
ndvi <- select(ndvi, 7:17) %>%
rename(Site = site)
ndvi$Site <- gsub("MoV", "Mov", ndvi$Site)
cov <- right_join(cov, ndvi, by = c("Site", "month"))
cov$sites <- paste(cov$Site, cov$month)
# Chunk 4
#cleaning the raw trait data
traits <- read.csv("raw data/Traits.csv")
#check for spelling mistakes in trait labels
unique(traits$Trait)
#I don't trust the eye width measurements because they were measured from the front
traits <- filter(traits, Trait != "Eye width")
#unique(traits$Photo)
#extract site IDs from photo names
traits <- separate(traits, Photo, c("Site", "Slide", "Specimen"))
traits$Site <- gsub("Papl", "PaPl", traits$Site)
unique(traits$Site)
traits <- traits[-1,]
#remove the double pheidole entry
traits <- traits[-2,]
#need to divide the trait values by weber's body length. I want to do this at the individual level, not dividing means by mean webers
traits <- select(traits, -X, -Label)
traits <- pivot_wider(traits, names_from = Trait, values_from = Measure)
traits <- mutate(traits, Femur.w = Femur/Webers, Scape.w = Scape/Webers, Mandible.w = `Mandible length`/Webers, Headl.w = `Head length`/Webers, Eyel.w = `Eye length`/Webers, Headw.w = `Head width`/Webers)
traits <- pivot_longer(traits, 5:17, names_to = "Trait", values_to = "Measure")
#check for ant species name typoes
unique(traits$X.1)
#some traits are NA because of damage to the specimen
traits <- drop_na(traits)
#calculate the mean value of the trait for each species at each site (population level trait values)
traits.ag <- group_by(traits, Site, X.1, Trait) %>%
summarise(mean = mean(Measure), sd = sd(Measure))
#create a data frame of the mean values for each species across all sites (species level trait values)
traits.sp <- group_by(traits, X.1, Trait) %>%
summarise(mean = mean(Measure), sd = sd(Measure))
# Chunk 5
#we could also try to log transform the abundances to reduce the impact of colony size
#this is presence absence
long.pres <- pivot_longer(wide, 2:14, names_to = "species", values_to = "count")
long.pres <- mutate(long.pres, count.bin = ifelse(count >= 1, 1, 0))
spe.bin <- long.pres
#get total abundance per trap
long.pres <- group_by(long.pres, uniID) %>%
mutate(total = sum(count.bin))
#calculate relative abundances
long.pres <- long.pres %>% mutate(rel.abun = count.bin/total)
traits.ag <- rename(traits.ag, species = X.1)
traits.ag$species <- gsub(" ", "", traits.ag$species)
#add sites to long
long.pres <- cov %>% select(Site, uniID) %>% right_join(long.pres, . , by = 'uniID')
#this adds NA traits to 0 abundances - species isn't found at pitfall or site
join.right <- right_join(traits.ag, long.pres, by = c("Site", "species"))
CWM.pres <- mutate(join.right, cwm.prod = mean*rel.abun)
CWM.pres <- group_by(CWM.pres, Site, uniID, Trait) %>% summarise(cwm = sum(cwm.prod))
#join environmental data to CWM trait dataframe
CWM.pres <- left_join(CWM.pres, cov, by = "uniID")
# Chunk 6
#make a presence/absence pitfall trap data frame
spe.bin <- select(spe.bin, 2, 3, 5)
spe.bin <- pivot_wider(spe.bin, names_from = species, values_from = count.bin)
spe.bin <- select(spe.bin, -11, -12)
# Chunk 7
mat <- pivot_wider(CWM.pres, names_from = Trait, values_from = cwm)
mat <- select(mat, 5:11, 14:17, 25:29, 31, 38:44, 46, 48, 51, 52, 54, 55, 57) %>% ungroup()
mat <- ungroup(mat) %>% select(-uniID)
mat <- drop_na(mat)
#str(mat)
M <- cor(mat)
corrplot::corrplot(M, method = "number")
# Chunk 8
# I want the PCA on traits
# make it wide again
traits.wide <- pivot_wider(traits, names_from = Trait, values_from = Measure)
#keep only weber lengthh standardized traits
traits.wide <- select(traits.wide, 11:17)
traits.wide <- drop_na(traits.wide)
traits.st <- decostand(traits.wide, method = "standardize")
traits.pca <- rda(traits.st)
#summary(traits.pca)
autoplot(traits.pca, xlab = "PCA 33.9%", ylab = "PCA 32.9%")
#PC3 is ~15%
# Chunk 9
trait.pop <- traits.ag
trait.pop$spepop <- paste(trait.pop$species, trait.pop$Site)
trait.pop <- ungroup(trait.pop) %>% select(spepop, Trait, mean)
trait.pop <- pivot_wider(trait.pop, names_from = Trait, values_from = mean)
trait.pop <- select(trait.pop, 1, 3, 5, 8, 9, 11, 13, 14)
trait.pop.st <- select(trait.pop, -1) %>% decostand(method = "standardize")
trait.pop.pca <- rda(trait.pop.st)
#summary(trait.pop.pca)
autoplot(trait.pop.pca, xlab = "PCA 35.8%", ylab = "PCA 32.2 %")
#PCA3 ~ 16%
# Chunk 10
env <- select(cov, 4:9, 12:14, 23:27, 29, 37:43, uniID) %>% drop_na()
env_sitelabels <- env$uniID
env <- select(env, -uniID)
#standardize to mean of zero etc
env.d <- decostand(env, method = "standardize")
env.pca <- rda(env.d)
a <- summary(env.pca)
b <- a$cont$importance
prop1 <- b[2,1] * 100
prop1 <- round(prop1, digits = 2)
prop2 <- b[2,2] * 100
prop2 <- round(prop2, digits = 2)
autoplot(env.pca, xlab = paste("PCA", prop1), ylab = paste("PCA", prop2))
score2 <- scores(env.pca, c(1,2, 3), 'sites')
score2 <- as.data.frame(cbind(score2, env_sitelabels))
# Chunk 11
env2 <- select(cov, 3:5, 8, 12:15, 37:43, sites) %>% drop_na() %>% distinct()
env2_sitelabels <- env2$sites
env2 <- select(env2, -sites)
#standardize to mean of zero etc
env.d2 <- decostand(env2, method = "standardize")
env.pca2 <- rda(env.d2)
a <- summary(env.pca2)
b <- a$cont$importance
prop1 <- b[2,1] * 100
prop1 <- round(prop1, digits = 2)
prop2 <- b[2,2] * 100
prop2 <- round(prop2, digits = 2)
#summary(env.pca2)
autoplot(env.pca2, xlab = paste("PCA", prop1), ylab = paste("PCA", prop2))
#sitescores <- scores(env.pca2, c(1,2, 3), 'sites')
envreduce <- select(env2, -esi, -arid, -10, -12, -13, -14)
env.reduce <- decostand(envreduce, method = "standardize")
env.pcareduce <- rda(env.reduce)
a <- summary(env.pcareduce)
b <- a$cont$importance
prop1 <- b[2,1] * 100
prop1 <- round(prop1, digits = 2)
prop2 <- b[2,2] * 100
prop2 <- round(prop2, digits = 2)
#summary(env.pcareduce)
autoplot(env.pcareduce , xlab = paste("PCA", prop1), ylab = paste("PCA", prop2) )
sitescores <- scores(env.pcareduce, c(1,2, 3), 'sites')
sitescores <- as.data.frame(cbind(sitescores, env2_sitelabels))
# Chunk 12
#need a species by trait matrix, but I want to use the population means
#make species name the name + site
site.pop <- select(cov, 1, 2, 31) %>% left_join(long.pres, ., by = 'uniID')
#count uniID per site and month
counts <- site.pop %>% group_by(Site.x, month, uniID) %>% count()
counts <- counts %>% group_by(Site.x, month) %>% count()
site.pop <- site.pop %>% group_by(Site.x, month, species) %>% summarize(total = sum(count.bin))
site.pop <- left_join(site.pop, counts, by = c("Site.x", "month"))
site.pop <- mutate(site.pop, pit.abun = total/n)
site.pop <- select(site.pop, 1:3, 6)
site.pop$site.name <- paste(site.pop$Site.x, site.pop$month)
site.pop$spepop <- paste(site.pop$species, site.pop$Site.x)
site.pop <- site.pop %>% ungroup() %>% select(4:6)
wide.pop <- pivot_wider(site.pop, names_from = spepop, values_from = pit.abun)
wide.pop[is.na(wide.pop)] <- 0
sites <- wide.pop$site.name
#there are no trait measurements for species that are absent from a site
wide.pop <- ungroup(wide.pop) %>% select(-site.name)
wide.pop <- wide.pop[which(colSums(wide.pop) !=0)]
wide.pop <- cbind(sites, wide.pop)
row.names(wide.pop) <- wide.pop$sites
wide.pop <- select(wide.pop, -sites)
#remove the two solenopsis singletons - no trait measuremnts
wide.pop <- select(wide.pop, -36, -42)
#check to ensure names are matched correctly between dataframes
spec <- colnames(wide.pop)
trait.pop <- as.data.frame(trait.pop)
row.names(trait.pop) <- trait.pop$spepop
trait.pop <- select(trait.pop, -spepop)
all.equal(spec, row.names(trait.pop))
# Chunk 13
#Lets create a matrix to store results from each iteration (one column per iteration)
#saving the randomization as an R object to cut down knit time
# numberReps <- 100
# resultsRandom <- matrix(NA, nrow = nrow(wide.pop), ncol = numberReps,
#                         dimnames = list(rownames(wide.pop),
#                                         paste0("Sim.", 1:numberReps)))
# for(rep in 1:numberReps){
#   randomizedFDis <- randomizeMatrix(samp = wide.pop, null.model = "independentswap")
#   simFDis <- dbFD(trait.pop, randomizedFDis, w.abun = TRUE)$FDis
#   resultsRandom[, rep] <- simFDis
# }
#saveRDS(resultsRandom, file = "Clean Data/objects/FDispRandom_sites.rds")
# Chunk 14
resultsRandom <- readRDS("Clean Data/objects/FDispRandom_sites.rds")
obsFDis <- dbFD(trait.pop, wide.pop, w.abun = TRUE)$FDis
meanNull3 <- rowMeans(resultsRandom)
ES3 <- obsFDis - meanNull3
sdNull3 <- apply(resultsRandom, 1, sd)
SES3 <- ES3 / sdNull3
SES_dis <- data.frame(SES3)
SES_dis$sites <- row.names(SES_dis)
#make random values negative
resultsRandom_neg <- resultsRandom * -1
diff <- sweep(resultsRandom_neg, 1, obsFDis, "+")
diff_ses <- sweep(diff, 1, meanNull3, "/")
diff_ses_ag <- apply(diff_ses, 1, multiple.func)
diff_ses_ag <- t(diff_ses_ag)
diff_ses_ag <- cbind(diff_ses_ag, SES_dis$sites)
#get rid of last row
diff_ses_ag <- head(diff_ses_ag, 27)
test <- cbind(sdNull3, diff_ses_ag)
test <- as.data.frame(test)
test$sd <- as.numeric(test$sd)
test <- rename(test, sdrand = sdNull3)
test$sdrand <- as.numeric(test$sdrand)
cor.test(test$sd, test$sdrand)
#variation in SES values is the same as the random variation in fdisp calculated from a null model
#join site-level environmental measurements to data
cov$sites <- paste(cov$Site, cov$month)
SES <- select(cov, 1:15, shrub.site, sites, 37:43) %>% distinct() %>% left_join(SES_dis, by = "sites")
# Chunk 15
SES2 <- cbind(SES, sitescores)
SES2$PC1 <- as.numeric(SES2$PC1)
SES2$PC2 <- as.numeric(SES2$PC2)
SES2$PC3 <- as.numeric(SES2$PC3)
#need to add raw FDisp score
mean(SES$SES3)
t.test(SES$SES3)
m1 <- lm(SES3 ~  PC1 + PC2 , data = SES2)
summary(m1)
shapiro.test(resid(m1))
ggplot(SES2, aes(PC1, SES3)) + geom_smooth(method = 'lm')
ggplot(SES2, aes(PC1, SES3, color = shrub.site)) + geom_smooth(method = 'lm')
SES2 <- mutate(SES2, shrub = ifelse(shrub.site == "atriplex", "shrub", (ifelse(shrub.site == "ephedra", "shrub", "open"))))
ggplot(SES2, aes(PC1, SES3, color = shrub)) + geom_smooth(method = 'lm')
ggplot(SES2, aes(PC1,SES3, color = shrub)) + geom_point()
ggplot(SES2, aes(PC1,SES3, color = Site)) + geom_point()
m2 <- lm(SES3 ~ arid, data = SES2)
summary(m2)
ggplot(SES2, aes(arid, SES3)) + geom_smooth(method = 'lm')
ggplot(SES2, aes(Temp, SES3)) + geom_smooth(method = 'lm')
ggplot(SES2, aes(Max, SES3)) + geom_smooth()
ggplot(SES2, aes(NDVI, SES3)) + geom_smooth(method = 'lm')
ggplot(SES2, aes(mean.cover, SES3)) + geom_smooth(method = 'lm')
ggplot(SES2, aes(var.cover, SES3)) + geom_smooth()
#new heat map
mat3 <- select(SES2, esi, 4,5, 8, 12:15, 18, 24, 24:28)
M3 <- cor(mat3)
corrplot::corrplot(M3, method = "number")
# Chunk 16
#use long pres
#join month by identifier
#remove the two singletons?
#sum presences per site
alpha <- select(cov, uniID, month) %>% right_join(long.pres, by = "uniID")
alpha$sites <- paste(alpha$Site, alpha$month)
alpha <- filter(alpha, species != "Solenopsisaurea" & species != "Solenopsismolesta")
alpha <- select(alpha, sites, species, count.bin)
alpha <- distinct(alpha)
alpha <- alpha %>% group_by(sites) %>% summarise(richness = sum(count.bin))
alpha <- right_join(alpha, SES2, by = "sites")
#same GLM or GLMM
m1 <- glmmTMB(richness ~ PC1 + PC2 + PC3 + (1|Site), family = "poisson", data = alpha)
summary(m1)
shapiro.test(resid(m1))
m2 <- glm(richness ~ Prec, family = "poisson", data = alpha)
summary(m2)
#maybe should use an abundance weighted diversity index for this
# Chunk 17
#functional indices are weighted so use abundance weighted beta-diversity
library(betapart)
# baselgi methods for beta-diversity
#we can use the occupancy population dateframe
#drop half of species name after space
#filter out two singletons
sites_species <- site.pop
sites_species <- separate(sites_species, spepop, into = c("species", "month"), sep = " ")
sites_species <- filter(sites_species, species != "Solenopsisaurea" & species != "Solenopsismolesta")
sites_species <- select(sites_species, -month)
# need wide
sites_species <- pivot_wider(sites_species, names_from = "species", values_from = "pit.abun") %>% as.data.frame()
row.names(sites_species) <- sites_species$site.name
sites_species <- select(sites_species, -site.name)
#balanced variation in abundance is turnover
#abundance gradients are nestedness
beta.core <- betapart.core.abund(sites_species)
betapair <- beta.pair.abund(beta.core)
betamulti <- beta.multi.abund(beta.core)
#turnover component
betamulti$beta.BRAY.BAL
#nestedness component
betamulti$beta.BRAY.GRA
#combined
betamulti$beta.BRAY
#mostly turnover, some nestedness
#betapair are dist objects
tdis <- betapair$beta.bray.bal
ndis <- betapair$beta.bray.gra
#let's use the standardized environmental variables from the pca scores
envbeta <- cbind(env.reduce, env2_sitelabels)
#sort envbeta to same order as site_species
envbeta <- envbeta[order(match(envbeta[,10], row.names(sites_species))),]
row.names(envbeta) <- envbeta$env2_sitelabels
envbeta <- select(envbeta, -env2_sitelabels)
env_dist <- dist(envbeta, "euclidean")
mantel(tdis, env_dist)
mantel(ndis, env_dist)
#turnover NOT related to env gradient
#nestedness - this is changes to abundance is related
#can I do mean at each site and plot against environment?
#look at me I'm varpart
library(adespatial)
library(SoDA)
#convert our degrees in lat long to cartesian
sites.xy <- geoXY(SES2$Lat.x, SES2$Long.x)
mem <- dbmem(sites.xy)
var_df <- cbind(SES2, sites.xy)
disp <- SES2$SES3
env <- select(SES2, 4, 5, 8, 12:14, 18, 19, 24)
v1 <- varpart(Y =disp, X = env, sites.xy)
summary(v1)
#showvarparts(v1)
plot(v1)
#rda(v1)
cwm <- site_cwm
cwm$sites <- row.names(cwm)
cwm <- select(SES2, sites, PC1, PC2, PC3) %>% left_join(cwm, by = 'sites')
ggplot(SES2, aes(PC1, SES3)) + geom_point() + geom_smooth(method = "lm")
ggplot(SES2, aes(PC1, SES3)) + geom_point() + stat_smooth(method = "lm") + xlab("") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))
ggplot(SES2, aes(PC1, SES3)) + geom_point() + stat_smooth(method = "lm") + xlab("PC1") + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black")) + ylab("SES Functional dispersion")
#summary(trait.pop.pca)
autoplot(trait.pop.pca, xlab = "PCA 35.8%", ylab = "PCA 32.2 %")
#summary(trait.pop.pca)
autoplot(trait.pop.pca, xlab = "PCA 35.8%", ylab = "PCA 32.2 %") +  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))
#summary(env.pca2)
autoplot(env.pca2, xlab = paste("PCA", prop1), ylab = paste("PCA", prop2))
autoplot(env.pca, xlab = paste("PCA", prop1), ylab = paste("PCA", prop2)) +  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))
autoplot(env.pca, xlab = paste("PCA", prop1), ylab = paste("PCA", prop2)) +  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))
env.d <- decostand(env, method = "standardize")
env.pca <- rda(env.d)
a <- summary(env.pca)
b <- a$cont$importance
prop1 <- b[2,1] * 100
prop1 <- round(prop1, digits = 2)
prop2 <- b[2,2] * 100
prop2 <- round(prop2, digits = 2)
autoplot(env.pca, xlab = paste("PCA", prop1), ylab = paste("PCA", prop2)) +  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))
